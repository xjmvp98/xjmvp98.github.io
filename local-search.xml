<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一文详细理解IssS、PaaS、SaaS、KaaS等</title>
    <link href="/2022/08/03/%E4%B8%80%E6%96%87%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3IssS%E3%80%81PaaS%E3%80%81SaaS%E3%80%81KaaS%E7%AD%89/"/>
    <url>/2022/08/03/%E4%B8%80%E6%96%87%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3IssS%E3%80%81PaaS%E3%80%81SaaS%E3%80%81KaaS%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一文详细理解IaaS、PaaS、SaaS、KaaS等"><a href="#一文详细理解IaaS、PaaS、SaaS、KaaS等" class="headerlink" title="一文详细理解IaaS、PaaS、SaaS、KaaS等"></a>一文详细理解IaaS、PaaS、SaaS、KaaS等</h1><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p>要理解这三个概念，首先就需要理解什么是云计算</p><p>关于云计算的通用定义如下：</p><blockquote><p>云计算是一种<strong>按使用量付费的模式</strong>。这种模式提供<strong>可用的、便捷的、按需的</strong>网络访问， 进入<strong>可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务）</strong>，这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p></blockquote><p>换句话说通俗的理解其实就是：</p><blockquote><p>所谓<strong>云化就是把每个人手中独立的资源集中起来，放在一个地方进行统一管理，然后再动态的分配给每个人使用</strong>；而<strong>云计算就是把计算资源集中起来，按需使用，动态分配给需要使用的人进行使用，这个计算资源，包括CPU、内存、硬盘等硬件还有软件</strong>。</p></blockquote><div align="center"><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/1620.jpeg" alt="img" style="zoom:67%;"></div><p>云计算就是让用户通过互联网来使用在云端的<strong>应用</strong>、<strong>数据</strong>或者<strong>服务</strong>。</p><div align="center"><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/1620-16595082821613.jpeg" alt="img" style="zoom:80%;"></div><p>那么在云计算的结构中，这些资源是如何提供的呢？就要引出如下的介绍</p><h2 id="传统云计算结构"><a href="#传统云计算结构" class="headerlink" title="传统云计算结构"></a>传统云计算结构</h2><p>IaaS -&gt; PaaS -&gt; SaaS</p><h3 id="什么是IaaS"><a href="#什么是IaaS" class="headerlink" title="什么是IaaS"></a>什么是IaaS</h3><p><strong>基础设施即服务 (<code>IaaS</code>)</strong> ：为云服务<strong>提供硬件</strong>，其中<strong>包括服务器、网络和存储</strong>。对于那些<strong>不想购买和维护基础设施的企业</strong>，这便是一个可以大大降低成本的战略。</p><p>常见示例如：亚马逊<code>AWS</code>、谷歌计算引擎、阿里云、腾讯云和微软<code>Azure</code>等。</p><h3 id="什么是PaaS"><a href="#什么是PaaS" class="headerlink" title="什么是PaaS"></a>什么是PaaS</h3><blockquote><p>A system that abstracts away hardware and software deployment,enabling developers to simply mix and match components for application creation.<br>一个针对开发人员的应用开发平台，抽象并解耦了硬件资源和软件部署，使开发人员能够依赖平台公共的组件和服务，简单快速的完成应用开发</p></blockquote><p><strong>平台即服务 (<code>PaaS</code>)</strong> ：除了提供<code>IaaS</code>可提供的<strong>所有硬件</strong>之外，还提供<strong>操作系统和数据库</strong>。</p><p>常见示例如：<code>AWS Elastic Beanstalk</code>和谷歌应用程序引擎等。</p><p><code>PaaS</code>可以提供丰富的应用的目录，开发者只要把这些堆栈组合起来，就可以快速的完成应用的开发。</p><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/image-20220803150521625.png" alt="image-20220803150521625" style="zoom: 50%;"><p>但是开发者一旦想要自定义很多的东西就会受到<code>PaaS</code>的制约</p><h3 id="什么是SaaS"><a href="#什么是SaaS" class="headerlink" title="什么是SaaS"></a>什么是SaaS</h3><p><strong>软件即服务 (<code>SaaS</code>)</strong> ：<strong>提供了最多的支持</strong>，即为您的最终用户<strong>提供除其数据之外的所有服务</strong>。<code>SaaS</code><strong>可以在多租户架构中</strong>运行，软件的<strong>一个实例可以为多个用户提供服务</strong>，<code>SaaS</code>产品<strong>一般不需要下载安装</strong>，并且对于企业用户来说，<strong>不需要管理软件的更新</strong>，他们<strong>只需要负责自己的数据即可</strong>。</p><p>常见示例如：基于云的文件存储（百度云网盘、腾讯微云等）和电子邮件等。</p><h3 id="一图通俗易懂解释IaaS、PaaS及SaaS"><a href="#一图通俗易懂解释IaaS、PaaS及SaaS" class="headerlink" title="一图通俗易懂解释IaaS、PaaS及SaaS"></a>一图通俗易懂解释IaaS、PaaS及SaaS</h3><p>以云厂商的视角为例（黄色）</p><div align="center"><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/image-20220722151934701.png" style="zoom:67%;"></div><p>我们可以注意到，对于<code>IaaS</code>(基础设施即服务)，一开始我们需要<strong>提供的只有硬件</strong>，即“成品材料”即可；而到了<code>PaaS</code>(平台即服务)，我们需要额外<strong>提供操作系统及数据库</strong>，也就是“成品材料以及处理材料的东西”；到了<code>SaaS</code>(软件即服务)，我们需要<strong>提供全部东西</strong>，用户只需要来拿走成品“披萨”即可；为此，我们可以看到，<strong>用户的方便性也在逐步的提升</strong>。</p><h2 id="新型云计算结构"><a href="#新型云计算结构" class="headerlink" title="新型云计算结构"></a>新型云计算结构</h2><p>IaaS -&gt; KaaS -&gt; PaaS -&gt; SaaS</p><h3 id="KaaS"><a href="#KaaS" class="headerlink" title="KaaS"></a>KaaS</h3><blockquote><p>A system that enables developers to deploy and&#x2F;or manage Kubernetes clusters in a self-service manner.<br>可以让一个开发者通过自服务的形式去管理（跨云部署[裸机or私有云or公有云]、生命周期管理[扩容、缩容、基础组件的升级等]）他自己的自服务的集群</p></blockquote><ul><li>可以部署在不同的基础架构资源上，能对集群的生命周期进行管理</li><li>可以在其上去实现<code>PaaS</code>平台</li></ul><p>常见示例如：<code>Rancher</code>、<code>VMware Kubernetes Management Platform</code>、<code>Google Kubernetes Engine(GKE)</code>、<code>Tencent Kubernetes Engine(TKE)</code>、<code>Azure Kubernetes Service(AKS)</code>等</p><h4 id="Strength：Developer-control"><a href="#Strength：Developer-control" class="headerlink" title="Strength：Developer control"></a>Strength：Developer control</h4><ul><li>Developers can choose what applications they want</li><li>Developers can spin up what resources they need</li><li>Developers can upgrade&#x2F;update their clusters</li><li>Developers can control security</li></ul><p>相对来说，对于开发者来说具有更高的灵活性，更加支持应用在生产环境的使用，因为可控性更强<br>但是同时，矛与盾是对立存在的，对于开发者来说，这也带来了弱点</p><h4 id="Weakness：Developer-control"><a href="#Weakness：Developer-control" class="headerlink" title="Weakness：Developer control"></a>Weakness：Developer control</h4><ul><li>Developers can choose what applications they want</li><li>Developers can spin up what resources they need</li><li>Developers can upgrade&#x2F;update their clusters</li><li>Developers can control security</li></ul><p>对于开发者来说需要知道的更多（架构、技术原理），需要做的更多</p><h4 id="Strength：Vendor-neutrality"><a href="#Strength：Vendor-neutrality" class="headerlink" title="Strength：Vendor neutrality"></a>Strength：Vendor neutrality</h4><ul><li>Not reliant on any proprietary&#x2F;system specific API</li><li>Can be migrated to any other Kubernetes system&#x2F;provider</li><li>Can be used with multiple Kubernetes providers</li></ul><p><code>KaaS</code>不会被供应商锁定。因为当我们一旦深入的使用了某个平台，对于<code>PaaS</code>来说很难去进行架构的切换；但是<code>KaaS</code>在架构这个层面是由用户自己决定的。因此，如果你有很大的研发能力，需要真正的去运行一个应用在生产环境，可以去选择<code>KaaS</code>,他只需要去关心，我的应用和架构做好之后怎么部署在<code>Kubernetes</code>集群上，由<code>Kubernetes</code>去管理他的高可用，将来无论是<code>AKS</code>还是<code>TKE</code>都可以去切换使用。</p><h3 id="如何选择KaaS还是PaaS"><a href="#如何选择KaaS还是PaaS" class="headerlink" title="如何选择KaaS还是PaaS"></a>如何选择KaaS还是PaaS</h3><p>因为<code>KaaS</code>和<code>PaaS</code>其实是有点像的，所以当我们决定去使用<code>KaaS</code>还是<code>PaaS</code>的时候，可以问一下自己如下问题:</p><ul><li><p>What are you trying to accomplish with your automation?</p><p>如果是希望有自动化，来帮助你完成集群的管理，那么就可以选择带有<code>KaaS</code>功能的产品；</p></li><li><p>How much of a guardrail do your developers need&#x2F;want?</p><p>如果希望有一个灵活的or高度自定义的架构，那么<code>KaaS</code>平台更适合你；如果希望开发者能快速的部署业务，那么<code>PaaS</code>平台更适合</p></li><li><p>How are you going to handle upgrades&#x2F;updates?</p><p>这里<code>KaaS</code>和<code>PaaS</code>都可以去解决</p></li><li><p>How many tenants&#x2F;applications do you have?</p><p>如果租户or应用比较多，那么可以采用<code>PaaS</code>平台；如果租户只有比较重要的几个，比较少，希望他有更高的可靠性，那么就可以基于<code>KaaS</code>去部署不同的集群</p></li><li><p>How much flexibility do you need in choosing your architecture?</p></li><li><p>Do you anticipate needing different clouds?Multiple clouds?</p></li><li><p>How predictable are your plans?</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>云原生安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入之预编译</title>
    <link href="/2022/06/17/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    <url>/2022/06/17/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E9%A2%84%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入之预编译"><a href="#SQL注入之预编译" class="headerlink" title="SQL注入之预编译"></a>SQL注入之预编译</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们都知道注入攻击常年霸占OWASP TOP10的绝对TOP 1，那么SQL注入在其中又是首当其冲。那么要预防SQL注入除了最常见的<strong>转义、过滤、拦截敏感字符</strong>外，安全从业者比较推荐的还有<strong>预编译</strong>的方法。那么本文将围绕预编译是什么？为什么预编译可以预防SQL注入？预编译真的能够完全防止SQL注入吗？这三个问题为主要切入点进行关于SQL注入预编译相关的介绍和讨论。</p></blockquote><h2 id="预编译介绍"><a href="#预编译介绍" class="headerlink" title="预编译介绍"></a>预编译介绍</h2><h3 id="什么是预编译"><a href="#什么是预编译" class="headerlink" title="什么是预编译"></a>什么是预编译</h3><p>SQL预编译其实就是一种分离数据（用户输入的数据）和代码（SQL指令）的一种方式，通俗的来说其实就是提前告诉SQL语法处理器，将未拼接参数的SQL语句提前进行声明和编译，然后将所有用户的输入视为纯字符参数传递给数据库，最后再组成查询语句去进行查询。此时，传递的参数就不会再被当作指令去进行执行了，只会当作普通的文本，也就达到了防止SQL注入的目的。</p><p>java中预编译操作流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建数据库连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc.mysql://localhost:3306/test?useUnicode=true&amp;charset=utf-8&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//2.将没有参数的SQL语句进行预编译(用?作为占位符)</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span>  conn.prepareStatement(<span class="hljs-string">&quot;select * from users where username=? and password=?&quot;</span>);<br><span class="hljs-comment">//3.设置参数</span><br>state.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;myusername&quot;</span>);<br>state.setString(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;mypassword&quot;</span>);<br><span class="hljs-comment">//4.执行sql语句</span><br><span class="hljs-type">Resultset</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> state.executeQuery();<br></code></pre></td></tr></table></figure><h3 id="预编译防止SQL注入的原因"><a href="#预编译防止SQL注入的原因" class="headerlink" title="预编译防止SQL注入的原因"></a>预编译防止SQL注入的原因</h3><p>刚才粗略的介绍了预编译能够防止SQL注入的原因，接下来从本质上分析一下为什么预编译能够防止SQL注入。</p><p>以MySQL为例，先介绍一下预编译的运行机制。在MySQL中一条SQL语句从传入到执行往往经历：检查缓存、规则验证、解析器解析为语法树、预处理器进一步验证语法树、优化SQL、生成执行计划、执行等步骤。其中对于语法的解析和优化过程其实是与传入的字段值无关的，但却比真正执行的过程更为耗费时间，因此在处理某些语句时，很容易造成时间的浪费，效率的下降，如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select *<span class="hljs-keyword">from</span> cloudcrowd <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>;<br>select *<span class="hljs-keyword">from</span> cloudcrowd <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>这两个语句由于后面的id值的不同，因此在检查缓存阶段就不会匹配，就不会得到重用，后面的所有阶段都要再依次进行，但是他们的语法树却是相似的，仅仅是id字段的值不同，因此如果每次都从检查缓存阶段重新开始，解析构造语法树就会造成极大的时间浪费。</p><p><img src="/.com//Xbr9jP.png" alt="语法树"></p><p>预编译的话会使用占位符?来代替字段值的部分，将SQL语句先交由数据库去进行预处理，构建语法树，再传入真正的字段值去进行多次执行，这样就会省略了重复解析和优化相同语法树的时间，提升了SQL执行的效率。</p><p>于是在传入字段值之前，由于语法树已经提前构造好了，因此无论传入任何字段值，都无法再更改语法树的结构。至此，任何传入的值都只会被当作值来看待，就不会再出现非预期的查询，这也就是预编译能够防止SQL注入的根本原因。</p><h3 id="使用了预编译就一定是安全了吗"><a href="#使用了预编译就一定是安全了吗" class="headerlink" title="使用了预编译就一定是安全了吗"></a>使用了预编译就一定是安全了吗</h3><p>并不会，主要有以下几种情况。无论什么时候，安全问题的产生往往就是两方面的因素：技术和人</p><h4 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h4><p>首先来说技术方面，预编译机制往往也会存在一些局限性。</p><h5 id="like语句"><a href="#like语句" class="headerlink" title="like语句"></a>like语句</h5><p>查询过程中我们有些时候会使用到like语句，比如查询名字中带有“高”的用户，我们可能会采取如下语句进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%高%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>此时，如果传入的参数为<code>%</code>，执行语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%%%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这种情况下预编译是可以通过的，会返回所有的用户</p><p><img src="/.com//image-20220617151352145.png" alt="image-20220617151352145"></p><h5 id="表名列名无法预编译"><a href="#表名列名无法预编译" class="headerlink" title="表名列名无法预编译"></a>表名列名无法预编译</h5><p>有代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">prepare</span>(<span class="hljs-string">&quot;select *from ? where id=?&quot;</span>);<br></code></pre></td></tr></table></figure><p>上面这段代码是错误的，因为表名和列名是不能够被预编译的，这是因为在生成语法树的过程中，预处理器在进一步检查解析后的语法树时，会检查数据表和数据列是否存在，因此数据表和数据列不能被占位符<code>?</code>所替代。</p><p>但在很多业务场景中，表名需要作为一个变量存在，因此这部分需要由+进行SQL语句的拼接，若表名是由外部传入并且可控的，那么就仍然会造成SQL注入。</p><p>同理，<code>order by</code>后的<code>ASC/DESC</code>也不能够被预编译，因此当业务场景涉及到用户可控制排序方式，且<code>ASC/DESC</code>是由前台传入并拼接到<code>SQL</code>语句上时，就也可能会出现危险了。</p><h6 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h6><p>可以在程序内部创建需要用到的表名的集合，每次查询时从集合中选出，由此避免表名被篡改，<code>ASC/DESC</code>也应在做严格检查后再拼接，最好不要由前台传入。任何的拼接都有可能出现问题，总体来说，正确的使用预编译还是可以杜绝SQL注入攻击的。</p><h5 id="动态传入的表名列名等"><a href="#动态传入的表名列名等" class="headerlink" title="动态传入的表名列名等"></a>动态传入的表名列名等</h5><p>java中如果使用<code>myhabtis</code>作为持久化框架，在<code>mapper.xml</code>中,如果入参使用<code>#</code>传值会使用预编译机制。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;query&quot;</span>&gt;</span><br>   select * from user<br>   <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>     name = #&#123;name&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但存在特殊情况，即动态传入列名和表名时会报错。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderBy&quot;</span>&gt;</span><br>   order by $&#123;sortString&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>sortString字段的内容是一个方法中动态计算出来的，这种情况是没法用<code>#</code>，代替<code>$</code>的，这样程序会报错，也就无法自动触发使用预编译机制。需要我们在服务端加入单独的过滤机制。</p><h3 id="人的方面"><a href="#人的方面" class="headerlink" title="人的方面"></a>人的方面</h3><p>预编译机制在理论上确实可以极大程度的避免SQL注入的发生，除了上述提到的特定场景下预编译机制有可能会失效外，其实还有要求就是<strong>应确保开发人员要正确的使用预编译</strong>，在代码审计中曾经发现过有些开发者虽然是使用了预编译机制，但是参数值仍然是由+拼接上去的，而不是正确的使用参数绑定，这样也就仍可以造成SQL注入。</p><h3 id="预编译的优点"><a href="#预编译的优点" class="headerlink" title="预编译的优点"></a>预编译的优点</h3><ol><li><p>可以提高访问数据库的性能</p><p>我们知道数据库在处理SQL语句时有一个预编译的过程，而预编译对象就是把一些格式固定的SQL语句编译之后，存放在内存池中（也就是数据库缓冲池），当我们再次执行相同的SQL语句时就不再需要预编译的过程了，只需要DBMS去运行SQL语句即可。</p><p>所以当你<font color="green">需要执行Statement对象多次的时候，PreparedStatement对象将会大大降低运行时间</font>，特别是大型数据库中，它可以有效地也加快了访问数据库的速度。（<a href="https://blog.csdn.net/weixin_43896929/article/details/122293768">关于Statement和PreparedStatement的介绍</a>&gt;）</p></li><li><p>可以防止SQL注入</p><p>使用预编译后，其后注入的参数将不会再进行SQL编译。也就是说<strong>其后注入进来的参数，系统将不会认为它会是一条SQL语句，而默认其是一个参数，参数中的 or 或者 and 等就不是SQL语法保留字了</strong>。</p></li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote><p><a href="https://blog.csdn.net/qq_43936524/article/details/115104527">https://blog.csdn.net/qq_43936524/article/details/115104527</a></p><p><a href="http://cn-sec.com/archives/246187.html">http://cn-sec.com/archives/246187.html</a></p><p><a href="https://blog.csdn.net/Just__2009/article/details/109126437?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-109126437-blog-123122623.pc_relevant_blogantidownloadv1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-109126437-blog-123122623.pc_relevant_blogantidownloadv1&amp;utm_relevant_index=1">https://blog.csdn.net/Just__2009/article/details/109126437?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-109126437-blog-123122623.pc_relevant_blogantidownloadv1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-109126437-blog-123122623.pc_relevant_blogantidownloadv1&amp;utm_relevant_index=1</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>任意文件下载漏洞原理解析</title>
    <link href="/2022/05/30/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    <url>/2022/05/30/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="任意文件下载漏洞原理解析"><a href="#任意文件下载漏洞原理解析" class="headerlink" title="任意文件下载漏洞原理解析"></a>任意文件下载漏洞原理解析</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>这种漏洞只有在获取到网站的管理员权限，进入到网站的管理才有可能会出现。</p><p>如果通过信息收集dirsearch或御剑，下载到网站的源码或备份文件也是属于任意文件下载漏洞。</p></blockquote><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>许多网站都会开放下载文件的功能，但是由于<strong>下载功能代码处对下载文件类型、目录未做限制或限制不当</strong>，<strong>导致攻击者可下载服务器任意文件</strong>。(例如：数据库配置文件<code>db.php</code>、<code>config.php</code>等) </p><p>某些文件下载功能实现过程是：<strong>根据参数filename的值，获得该文件在网站上的绝对路径，读取文件，然后直接发送给客户端下载</strong>。开发者如果没有对传入的参数<code>filename</code>进行过滤，攻击者就可以利用该漏洞下载服务器上任何文件，于是就产生<strong>任意文件下载漏洞</strong>。</p><p>某个实际下载过程如下：</p><p><img src="https://s1.ax1x.com/2022/05/30/X1aqfg.png" alt="img"></p><p>我们如果将path后面的路径修改为<code>/etc/passwd</code>,那么我们是不是就可以下载到其他文件了呢？</p><p><img src="https://s1.ax1x.com/2022/05/30/X1dihF.png" alt="image 20220530111907363"></p><p>这个漏洞产生的<strong>核心原理</strong>就是：<strong>下载的参数是用户可控的，并不是写死的</strong>，于是就产生了任意文件下载漏洞。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ol><li>任意文件下载漏洞正常的利用手段是<strong>下载服务器文件</strong>，如脚本代码、服务器配置文件或者是系统配置文件等。</li><li>但是有的时候我们可能根本就不知道网站所处的环境，以及网站的路径，这时候我们只能利用<code>./ ../</code>来逐层猜测路径。</li></ol><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ol><li>下载服务器上的任意文件，如：脚本代码、服务及系统配置文件等</li><li>对下载得到的代码，进行进一步代码审计，得到更多可利用的漏洞。</li></ol><h3 id="寻找方式"><a href="#寻找方式" class="headerlink" title="寻找方式"></a>寻找方式</h3><p>1、Google hack语法利用</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">inurl:</span><span class="hljs-string">&quot;readfile.php?file=&quot;</span><br></code></pre></td></tr></table></figure><p>2、从链接上看</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>download.php?path=<br><span class="hljs-bullet">- </span>download.php?file=<br><span class="hljs-bullet">- </span>down.php?file=<br><span class="hljs-bullet">- </span>data.php?file=<br><span class="hljs-bullet">- </span>readfile.php?file=<br><span class="hljs-bullet">- </span>read.php?filename=<br></code></pre></td></tr></table></figure><p>3、从参数名看</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso">- $RealPath=<br>- $FilePath=<br>- $filepath=<br>- $Filepath=<br>- $Path=<br>- $path=<br>- $inputFile=<br>- $Inputfile=<br>- $url=<br>- $urls=<br>- <span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><h2 id="二、漏洞利用"><a href="#二、漏洞利用" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h2><blockquote><p>利用任意文件下载漏洞，我们就可以读取服务器上常规的配置文件、下载各种<code>.log</code>文件， 也可以尝试读取<code>/root/.bash_history</code>看自己是否具有<code>root</code>权限、读取<code>mysql</code>下的<code>bash_history</code>文件等。</p></blockquote><p>因为很多时候我们打进内网之后没有办法进行其余操作了，那么我们就可以尝试用<code>history</code>命令或读取查看<code>/root/.bash_history</code>和<code>/root/.mysql_history</code>来尝试查看一下曾经别人执行过的命令，我们就有可能看到有的人执行过的一些敏感操作。</p><p>例如：有的人如果执行过一些文件操作，那么我们就有可能进而摸索出网站的系统文件结构是什么样的；还有有的人可能会执行过一些改密码的操作，我们同样可以得到用户的密码等。</p><p><img src="https://s1.ax1x.com/2022/05/30/X1dGjA.png" alt="image 20220530130534000"></p><p>另外，在linux中有这样一个命令<code> locate</code>，它可以用来查找文件或目录，它并不是从具体目录进行搜索，而是搜索一个数据库:<code>/var/lib/mlocate/mlocate.db</code>。<br>这个数据库中含有本地所有文件信息，而且Linux系统会自动创建这个数据库，并且每天自动更新1次。</p><p>例如：读取<code>mlocate.db</code>文件内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/mlocate/m</span>locate.db<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/05/30/X1dNHP.png" alt="image 20220530131130521"></p><p>其中包含了特别多的文件内容</p><p>于是我们就可以利用任意文件下载漏洞将<code>mlocate.db</code>文件下载下来，然后利用<code>locate</code>命令将数据输出成文件，这里面包含了全部的文件路径信息。</p><p><strong>例：利用locate命令读取包含admin内容的全部路径</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">locate mlocate<span class="hljs-meta">.db</span> admin<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/05/30/X1dsjs.png" alt="image 20220530131411153"></p><p>因此利用这个命令我们可以将<code>mlocate.db</code>内所有包含<code>admin</code>内容全部输出出来，利用<code>mlocate.db</code>这个文件我们就可以获取到该服务器上任何攻击者想要的内容，并针对性的下载下来，从而不用一个个猜解目录，但是这个文件只有<code>root</code>用户才可以读取。</p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><p><strong>常见敏感文件</strong></p><p>系统都存在的文件，用来验证漏洞是否存在</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Windows:</span><br><span class="hljs-symbol">C:</span>\boot.ini <span class="hljs-comment">//查看系统版本</span><br><span class="hljs-symbol">C:</span>\Windows\System32\inetsrv\MetaBase.xml <span class="hljs-comment">//IIS配置文件</span><br><span class="hljs-symbol">C:</span>\Windows\repair\sam <span class="hljs-comment">//存储系统初次安装的密码</span><br><span class="hljs-symbol">C:</span>\Program Files\mysq1\my.ini <span class="hljs-comment">//Mysql配置</span><br><span class="hljs-symbol">C:</span>\Program Files\mysql\data\mysq1\user.MYD <span class="hljs-comment">//Mysql root</span><br><span class="hljs-symbol">C:</span>\Windows\php.ini <span class="hljs-comment">//php配置信息</span><br><span class="hljs-symbol">C:</span>\Windows\my.ini <span class="hljs-comment">//Mysql配置信息</span><br><span class="hljs-symbol">C:</span>\Windows\win.ini <span class="hljs-comment">//Windows 系统的一个基本系统配置文件</span><br><br></code></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Linux:</span><br><span class="hljs-keyword">/root/</span>.ssh/authorized keys<br><span class="hljs-keyword">/root/</span>.ssh/id_rsa<br><span class="hljs-keyword">/root/</span>.ssh/id_ras.keystore<br><span class="hljs-keyword">/root/</span>.ssh/known_hosts <span class="hljs-comment">//记录每个访问计算机用户的公钥</span><br><span class="hljs-keyword">/etc/</span>passwd<br><span class="hljs-keyword">/etc/</span>shadow<br><span class="hljs-keyword">/etc/</span>my.cnf <span class="hljs-comment">//mysql配置文件</span><br><span class="hljs-keyword">/etc/</span>httpd<span class="hljs-keyword">/conf/</span>httpd.conf <span class="hljs-comment">//apache配置文件</span><br><span class="hljs-keyword">/root/</span>.bash_history <span class="hljs-comment">//用户历史命令记录文件</span><br><span class="hljs-keyword">/root/</span>.mysql_history <span class="hljs-comment">//mysql历史命令记录文件</span><br>......<br></code></pre></td></tr></table></figure><p><strong>漏洞格式</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">index.php?f=../../../../../etc/passwd<br>index.php?f=../index.php<br>index.php?f=file:<span class="hljs-comment">///etc/passwd</span><br></code></pre></td></tr></table></figure><blockquote><p>注：当参数f的值为php文件时，若是文件被解析则是文件包含漏洞，若是显示的是文件源码或者提示下载，则是任意文件查看或下载漏洞。</p></blockquote><h2 id="三、靶场演练"><a href="#三、靶场演练" class="headerlink" title="三、靶场演练"></a>三、靶场演练</h2><h3 id="以pikachu靶场为例："><a href="#以pikachu靶场为例：" class="headerlink" title="以pikachu靶场为例："></a>以pikachu靶场为例：</h3><p>打开靶场我们首先看到的是对于任意文件下载靶场的介绍：</p><p><img src="https://s1.ax1x.com/2022/05/30/X1dREV.png" alt="image 20220530163836514"></p><p>然后我们进入靶场，开始实战</p><p>靶场给了一堆图片说是我们可以进行下载</p><p><img src="https://s1.ax1x.com/2022/05/30/X1d4CF.png" alt="image 20220530163940505"></p><p>那么我们就点击第一个图片科比进行下载尝试（利用Burp抓包）：</p><p><img src="https://s1.ax1x.com/2022/05/30/X1dov9.png" alt="image 20220530164026702"></p><p>点击之后我们注意到数据包里有一个十分敏感的传参<code>?filename=kb.png</code>,那么这个传参会不会就决定了我们下载哪个文件呢？</p><p><img src="https://s1.ax1x.com/2022/05/30/X1wSvd.png" alt="image 20220530164130565"></p><p>我们在点击第二个图片下载抓包查看</p><p><img src="https://s1.ax1x.com/2022/05/30/X1wkUf.png" alt="image 20220530164245316"></p><p>我们注意到这时候文件的传参值变为了<code>ai.png</code></p><p><img src="https://s1.ax1x.com/2022/05/30/X1wkUf.png" alt="image 20220530164245316"></p><p>那么我们是不是就可以尝试下修改第一个传参值为第二个文件名，看看是否能下载下来，如果能下载下来，那么久存在任意文件下载漏洞。</p><p>于是我们继续抓包修改传参值</p><p><img src="https://s1.ax1x.com/2022/05/30/X1w1aV.png" alt="image 20220530164508445"></p><p>然后我们发现我们成功的下载下来了ai.png这个文件，于是也就说明这里存在任意文件下载漏洞。</p><p><img src="https://s1.ax1x.com/2022/05/30/X1wdq1.png" alt="image 20220530164607126"></p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>很多时候我们进行尝试的时候，对方可能会有检测，针对任意文件下载可能更多的是针对于<code>../</code>进行一个检测，于是我们可以尝试对<code>../</code>进行一个变形，并利用URL编码的方式尝试一个绕过。</p><p><strong>常见URL编码绕过技术</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-variable">%2</span>e<span class="hljs-variable">%2</span>e<span class="hljs-variable">%2</span>f 等于 ../<br><span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/ 等于 ../<br>..<span class="hljs-variable">%2</span>f 等于 ../<br><span class="hljs-variable">%2</span>e<span class="hljs-variable">%2</span>e<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span> 等于 ..\<br>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span> 等于 ..\<br><span class="hljs-variable">%252</span>e<span class="hljs-variable">%252</span>e<span class="hljs-variable">%252</span>f 等于 ../<br>..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af../  等于 ../../   （％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af是<span class="hljs-string">&quot;/&quot;</span>字符的非法 UTF－<span class="hljs-number">8</span>表示方式）<br></code></pre></td></tr></table></figure><p>例如：(替换后)</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/boot.ini<br>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>/boot.ini<br>..<span class="hljs-variable">%2</span>f..<span class="hljs-variable">%2</span>f..<span class="hljs-variable">%2</span>f..<span class="hljs-variable">%2</span>f..<span class="hljs-variable">%2</span>f..<span class="hljs-variable">%2</span>fetc/passwd<br>..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af/../..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af/../..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af/../..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af/../..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af/../boot.ini<br></code></pre></td></tr></table></figure><p><strong>其他绕过技术</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/../</span>.<span class="hljs-regexp">/../</span>.<span class="hljs-regexp">/../</span><br>............../<br>.\\\\..\\\\<br>... ...<br></code></pre></td></tr></table></figure><p><strong>其他特殊容器支持的编码</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm">..<span class="hljs-variable">%c1</span>(pc|af|<span class="hljs-number">9</span><span class="hljs-keyword">c</span>|<span class="hljs-number">1</span><span class="hljs-keyword">c</span>|<span class="hljs-number">8</span>s)<br>..<span class="hljs-variable">%c0</span>(af|<span class="hljs-number">9</span>v|qf|<span class="hljs-number">2</span>f|<span class="hljs-number">5</span><span class="hljs-keyword">c</span>)<br>..<span class="hljs-variable">%f8</span><span class="hljs-variable">%80</span><span class="hljs-variable">%80</span><span class="hljs-variable">%af</span><br>..<span class="hljs-variable">%e0</span><span class="hljs-variable">%80</span><span class="hljs-variable">%af</span><br>..<span class="hljs-variable">%u0025u005c</span><br><span class="hljs-variable">%c0</span><span class="hljs-variable">%ce</span><span class="hljs-variable">%c0</span><span class="hljs-variable">%ae</span><br><span class="hljs-variable">%c0.</span><span class="hljs-variable">%c0.</span><br>... ...<br></code></pre></td></tr></table></figure><h3 id="危害最大化"><a href="#危害最大化" class="headerlink" title="危害最大化"></a>危害最大化</h3><ol><li><p><strong>下载网站本身源代码</strong></p><p>自己本地搭建进行代码审计</p></li><li><p><strong>jsp站点</strong></p><p>​下载Tomcat的配置文件<code>tomcat-users.xml</code> (里面保存登录的用户名和密码)，<code>tomcat-users.xml</code>在<code>conf</code>文件夹下，这样就可以直接使用下载点下载该文件。然后使用账号密码登录Tomcat,上传war拿shell。<br>​网站的配置文件jsp的配置文件放在根目录<code>WEB-INF/Web.xml</code>下(一般都有很多内容,有时含有数据库连接用户名和密码等关键信息)。</p></li><li><p><strong>aspx站点</strong></p><p>​利用sqI server渗透。aspx站点用根目录下的<code>web.config</code>文件保存配置信息，下载<code>web.config</code>文件，打开配置文件找到数据库账号密码。然后通过报错获取网站绝对路径，然后连接数据库使用差异备份获得shell。</p><p>​下载dlI文件。Aspx站点一般都会对后台源代码进行编译封装，保存到dIl文件中，放到网站根目录的Bin文件夹下，因此，可以利用下载点下载dll文件，获得网站源代码(并不会很全) 。使用.net reflector工具打开编译后的dll文件，获得网站源代码。</p></li><li><p><strong>asp站点</strong></p><p>找到后台登陆入口，下载该登陆界面，找到数据库连接文件（在<code>inc/conn.asp</code>中），下载<code>conn.asp</code>文件，找到数据库路径，直接下载access数据库，找到管理员密码登陆后台，利用后台的上传功能，上传shell。</p></li><li><p><strong>php站点</strong></p><p>下载<code>config.php</code>获得mysql数据库的用户名和密码，登录phpMyAdmin，使用日志写shell。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
