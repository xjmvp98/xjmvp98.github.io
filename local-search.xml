<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go语言的特性及发展前景</title>
    <link href="/2022/08/05/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E6%80%A7%E5%8F%8A%E5%8F%91%E5%B1%95%E5%89%8D%E6%99%AF/"/>
    <url>/2022/08/05/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E6%80%A7%E5%8F%8A%E5%8F%91%E5%B1%95%E5%89%8D%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Go语言的特性及发展前景"><a href="#Go语言的特性及发展前景" class="headerlink" title="Go语言的特性及发展前景"></a>Go语言的特性及发展前景</h1><p>Go语言也称为 Golang，是由 Google 公司开发的一种<strong>静态强类型、编译型、并发型</strong>、并具有<strong>垃圾回收功能</strong>的编程语言。</p><h2 id="Go语言的特性"><a href="#Go语言的特性" class="headerlink" title="Go语言的特性"></a>Go语言的特性</h2><h3 id="语法简单"><a href="#语法简单" class="headerlink" title="语法简单"></a>语法简单</h3><p>抛开语法样式不谈，单就类型和规则而言，<strong>Go 与 C99、C11 相似之处颇多</strong>，这也是Go语言被冠以“NextC”名号的重要原因。</p><p>C语言的语法处于简单和复杂的两极。C语言简单到你每写下一行代码，都能在脑中想象出编译后的模样，指令如何执行，内存如何分配，等等。而 C 的复杂在于，它有太多隐晦而不着边际的规则，着实让人头疼。相比较而言，Go 从零开始，没有历史包袱，在汲取众多经验教训后，可从头规划一个规则严谨、条理简单的世界。</p><p>Go语言的语法规则严谨，没有歧义，更没什么黑魔法变异用法。任何人写出的代码都基本一致，这使得Go语言简单易学。<strong>放弃部分“灵活”和“自由”，换来更好的维护性</strong>，我觉得是值得的。</p><p><strong>将“++”、“–”从运算符降级为语句，保留指针，但默认阻止指针运算</strong>，带来的好处是显而易见的。还有，<strong>将切片和字典作为内置类型，从运行时的层面进行优化</strong>，这也算是一种“简单”。</p><h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>时至今日，并发编程已成为程序员的基本技能，在各个技术社区都能看到诸多与之相关的讨论主题。在这种情况下Go语言却一反常态做了件极大胆的事，<strong>从根本上将一切都并发化</strong>，<strong>运行时用 <code>Goroutine</code> 运行所有的一切，包括 <code>main.main</code> 入口函数</strong>。</p><p>可以说，<code>Goroutine</code>（Go协程） 是 Go 最显著的特征。它<strong>用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理</strong>。这使得语法上的<strong>并发编程变得极为容易，无须处理回调，无须关注线程切换，仅一个关键字，简单而自然</strong>。</p><p>搭配 <code>channel</code>，实现 <code>CSP</code> 模型。<strong>将并发单元间的数据耦合拆解开来，各司其职</strong>，这对所有纠结于内存共享、锁粒度的开发人员都是一个可期盼的解脱。<strong>若说有所不足，那就是应该有个更大的计划，将通信从进程内拓展到进程外，实现真正意义上的分布式</strong>。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>将一切并发化固然是好，但带来的问题同样很多。<strong>如何实现高并发下的内存分配和管理就是个难题</strong>。好在 Go 选择了 <code>tcmalloc</code>，它<strong>本就是为并发而设计的高性能内存分配组件</strong>。</p><p>可以说，<strong>内存分配器</strong>是运行时三大组件里变化最少的部分。刨去因配合垃圾回收器而修改的内容，内存分配器完整保留了 <code>tcmalloc</code> 的原始架构。使用 <code>cache</code> 为当前执行线程提供无锁分配，多个 <code>central</code> 在不同线程间平衡内存单元复用。在更高层次里，heap 则管理着大块内存，用以切分成不同等级的复用内存块。快速分配和二级内存平衡机制，让内存分配器能优秀地完成高压力下的内存管理任务。</p><p>在最近几个版本中，编译器优化卓有成效。它会竭力将对象分配在栈上，以降低垃圾回收压力，减少管理消耗，提升执行性能。可以说，<strong>除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无须参与内存管理操作</strong>。</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>垃圾回收一直是个难题。早年间，<a href="http://c.biancheng.net/java/">Java</a> 就因垃圾回收低效被嘲笑了许久，后来 Sun 连续收纳了好多人和技术才发展到今天。可即便如此，在 Hadoop 等大内存应用场景下，垃圾回收依旧捉襟见肘、步履维艰。</p><p>相比 Java，Go 面临的困难要更多。因指针的存在，所以回收内存不能做收缩处理。幸好，指针运算被阻止，否则要做到精确回收都难。</p><p>每次升级，垃圾回收器必然是核心组件里修改最多的部分。从并发清理，到降低 <code>STW</code> 时间，直到 Go 的 1.5 版本实现并发标记，逐步引入三色标记和写屏障等等，都是为了能让垃圾回收在不影响用户逻辑的情况下更好地工作。尽管有了努力，当前版本的垃圾回收算法也只能说堪用，离好用尚有不少距离。</p><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>Go 刚发布时，静态链接被当作优点宣传。只须编译后的一个可执行文件，无须附加任何东西就能部署。这似乎很不错，只是后来风气变了。连着几个版本，编译器都在完善动态库 <code>buildmode</code> 功能，场面一时变得有些尴尬。</p><p>暂不说未完工的 <code>buildmode</code> 模式，静态编译的好处显而易见。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。这种简单方式对于编写系统软件有着极大好处，因为库依赖一直都是个麻烦。</p><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>功能完善、质量可靠的标准库为编程语言提供了充足动力。在不借助第三方扩展的情况下，就可完成大部分基础功能开发，这大大降低了学习和使用成本。最关键的是，标准库有升级和修复保障，还能从运行时获得深层次优化的便利，这是第三方库所不具备的。</p><p>Go 标准库虽称不得完全覆盖，但也算极为丰富。其中值得称道的是 <code>net/http</code>，仅须简单几条语句就能实现一个高性能 <code>Web Server</code>，这从来都是宣传的亮点。更何况大批基于此的优秀第三方 Framework 更是将 Go 推到 <code>Web/Microservice</code> 开发标准之一的位置。</p><p>当然，优秀第三方资源也是语言生态圈的重要组成部分。近年来崛起的几门语言中，Go 算是独树一帜，大批优秀作品频繁涌现，这也给我们学习 Go 提供了很好的参照。</p><h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><p>完整的工具链对于日常开发极为重要。Go 在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具。其功能未必完善，但起码算得上简单易用。</p><p><strong>内置完整测试框架</strong>，其中包括<strong>单元测试、性能测试、代码覆盖率、数据竞争</strong>，以及用来调优的 <code>prof</code>，这些都是保障代码能正确而稳定运行的必备利器。</p><p>除此之外，还可通过环境变量输出运行时监控信息，尤其是垃圾回收和并发调度跟踪，可进一步帮助我们改进算法，获得更佳的运行期表现。</p><h2 id="Go语言是为并发而生"><a href="#Go语言是为并发而生" class="headerlink" title="Go语言是为并发而生"></a>Go语言是为并发而生</h2><p>在早期 CPU 都是以单核的形式顺序执行机器指令。Go语言的祖先C语言正是这种顺序编程语言的代表。顺序编程语言中的顺序是指：<strong>所有的指令都是以串行的方式执行，在相同的时刻有且仅有一个 CPU 在顺序执行程序的指令。</strong></p><p>随着处理器技术的发展，单核时代以提升处理器频率来提高运行效率的方式遇到了瓶颈，单核 CPU 发展的停滞，给多核 CPU 的发展带来了机遇。相应地，编程语言也开始逐步向并行化的方向发展。</p><p>虽然一些编程语言的框架在不断地提高多核资源使用效率，例如 <a href="http://c.biancheng.net/java/">Java</a> 的 <code>Netty</code> 等，但仍然需要开发人员花费大量的时间和精力搞懂这些框架的运行原理后才能熟练掌握。</p><p>作为程序员，要开发出能充分利用硬件资源的应用程序是一件很难的事情。现代计算机都拥有多个核，但是大部分编程语言都没有有效的工具让程序可以轻易利用这些资源。<strong>编程时需要写大量的线程同步代码来利用多个核，很容易导致错误</strong>。</p><p>Go语言正是在多核和网络化的时代背景下诞生的原生支持并发的编程语言。Go语言从底层原生支持并发，无须第三方库，开发人员可以很轻松地在编写程序时决定怎么使用 CPU 资源。</p><p>Go语言的并发是基于 <code>goroutine</code> 的，<code>goroutine</code> 类似于线程，但并非线程。可以将 <code>goroutine</code> 理解为一种虚拟线程。Go语言运行时会参与调度 <code>goroutine</code>，并将 <code>goroutine</code> 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能。</p><p>多个 <code>goroutine</code> 中，Go语言使用通道（<code>channel</code>）进行通信，通道是一种内置的<a href="http://c.biancheng.net/data_structure/">数据结构</a>，可以让用户在不同的 <code>goroutine</code> 之间同步发送具有类型的消息。这让编程模型更倾向于在 <code>goroutine</code> 之间发送消息，而不是让多个 <code>goroutine</code> 争夺同一个数据的使用权。</p><p>程序可以将需要并发的环节设计为<strong>生产者模式和消费者的模式</strong>，将数据放入通道。通道另外一端的代码将这些数据进行并发计算并返回结果，如下图所示。</p><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/1-1PPQ001322K.jpg" alt="img" style="zoom: 80%;"><blockquote><p>提示：Go语言通过通道可以实现多个 <code>goroutine</code> 之间内存共享。</p></blockquote><p>【实例】生产者每秒生成一个字符串，并通过通道传给消费者，生产者使用两个 goroutine 并发运行，消费者在 main() 函数的 goroutine 中进行处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;fmt&quot;</span><br>        <span class="hljs-string">&quot;math/rand&quot;</span><br>        <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 数据生产者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(header <span class="hljs-type">string</span>, channel <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> &#123;<br>     <span class="hljs-comment">// 无限循环, 不停地生产数据</span><br>     <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-comment">// 将随机数和字符串格式化为字符串发送给通道</span><br>            channel &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s: %v&quot;</span>, header, rand.Int31())<br>            <span class="hljs-comment">// 等待1秒</span><br>            time.Sleep(time.Second)<br>        &#125;<br>&#125;<br><br><span class="hljs-comment">// 数据消费者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">customer</span><span class="hljs-params">(channel &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>     <span class="hljs-comment">// 不停地获取数据</span><br>     <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-comment">// 从通道中取出数据, 此处会阻塞直到信道中返回数据</span><br>            message := &lt;-channel<br>            <span class="hljs-comment">// 打印数据</span><br>            fmt.Println(message)<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个字符串类型的通道</span><br>    channel := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-comment">// 创建producer()函数的并发goroutine</span><br>    <span class="hljs-keyword">go</span> producer(<span class="hljs-string">&quot;cat&quot;</span>, channel)<br>    <span class="hljs-keyword">go</span> producer(<span class="hljs-string">&quot;dog&quot;</span>, channel)<br>    <span class="hljs-comment">// 数据消费函数</span><br>    customer(channel)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">dog: <span class="hljs-number">2019727887</span><br>cat: <span class="hljs-number">1298498081</span><br>dog: <span class="hljs-number">939984059</span><br>cat: <span class="hljs-number">1427131847</span><br>cat: <span class="hljs-number">911902081</span><br>dog: <span class="hljs-number">1474941318</span><br>dog: <span class="hljs-number">140954425</span><br>cat: <span class="hljs-number">336122540</span><br>cat: <span class="hljs-number">208240456</span><br>dog: <span class="hljs-number">646203300</span><br></code></pre></td></tr></table></figure><p>对代码的分析：</p><ul><li><p>第 03 行，导入格式化（<code>fmt</code>）、随机数（<code>math/rand</code>）、时间（<code>time</code>）包参与编译。</p></li><li><p>第 10 行，生产数据的函数，传入一个标记类型的字符串及一个只能写入的通道。</p></li><li><p>第 12 行，for{} 构成一个无限循环。</p></li><li><p>第 14 行，使用 <code>rand.Int31()</code> 生成一个随机数，使用 <code>fmt.Sprintf()</code> 函数将 <code>header</code> 和随机数格式化为字符串。</p></li><li><p>第 16 行，使用 <code>time.Sleep()</code> 函数暂停 1 秒再执行这个函数。如果在 <code>goroutine</code> 中执行时，暂停不会影响其他 <code>goroutine</code> 的执行。</p></li><li><p>第 21 行，消费数据的函数，传入一个只能写入的通道。</p></li><li><p>第 23 行，构造一个不断消费消息的循环。</p></li><li><p>第 25 行，从通道中取出数据。</p></li><li><p>第 27 行，将取出的数据进行打印。</p></li><li><p>第 31 行，程序的入口函数，总是在程序开始时执行。</p></li><li><p>第 33 行，实例化一个字符串类型的通道。</p></li><li><p>第 35 行和第 36 行，并发执行一个生产者函数，两行分别创建了这个函数搭配不同参数的两个 <code>goroutine</code>。</p></li><li><p>第 48 行，执行消费者函数通过通道进行数据消费。</p></li></ul><p>整段代码中，没有线程创建，没有线程池也没有加锁，仅仅通过关键字 go 实现 <code>goroutine</code>，和通道实现数据交换。</p><h2 id="目前有哪些项目是用Go语言开发的"><a href="#目前有哪些项目是用Go语言开发的" class="headerlink" title="目前有哪些项目是用Go语言开发的"></a>目前有哪些项目是用Go语言开发的</h2><p>所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go语言从发布 1.0 版本以来备受众多开发者关注并得到广泛使用，Go语言的<strong>简单、高效、并发</strong>特性吸引了众多传统语言开发者的加入，而且人数越来越多。</p><p>使用Go语言开发的开源项目非常多。早期的Go语言开源项目只是通过Go语言与传统项目进行C语言库绑定实现，例如 <a href="http://c.biancheng.net/qt/">Qt</a>、<code>Sqlite</code> 等；后期的很多项目都使用Go语言进行重新原生实现，这个过程相对于其他语言要简单一些，这也促成了大量使用Go语言原生开发项目的出现。</p><p>下面列举的是原生使用Go语言进行开发的部分项目。</p><h3 id="1-Docker"><a href="#1-Docker" class="headerlink" title="1) Docker"></a>1) Docker</h3><p><strong>Docker 是一种操作系统层面的虚拟化技术</strong>，<strong>可以在操作系统和应用程序之间进行隔离，也可以称之为容器</strong>。<strong>Docker 可以在一台物理服务器上快速运行一个或多个实例</strong>。例如，启动一个 <code>CentOS</code> 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。</p><p>项目链接：<a href="https://github.com/docker/docker">https://github.com/docker/docker</a></p><h3 id="2-Go语言"><a href="#2-Go语言" class="headerlink" title="2) Go语言"></a>2) Go语言</h3><p>Go语言自己的早期源码使用C语言和<a href="http://c.biancheng.net/asm/">汇编语言</a>写成。从 Go 1.5 版本后，完全使用Go语言自身进行编写。Go语言的源码对了解Go语言的底层调度有极大的参考意义，建议希望对Go语言有深入了解的读者读一读。</p><p>项目链接：<a href="https://github.com/golang/go">https://github.com/golang/go</a></p><h3 id="3-Kubernetes"><a href="#3-Kubernetes" class="headerlink" title="3) Kubernetes"></a>3) Kubernetes</h3><p>Google 公司开发的<strong>构建于 Docker 之上的容器调度服务</strong>，<strong>用户可以通过 <code>Kubernetes</code> 集群进行云端容器集群管理</strong>。<strong>系统会自动选取合适的工作节点来执行具体的容器集群调度处理工作</strong>。其核心概念是 <strong>Container Pod（容器仓）</strong>。</p><p>项目链接：<a href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a></p><h3 id="4-etcd"><a href="#4-etcd" class="headerlink" title="4) etcd"></a>4) etcd</h3><p>一款分布式、可靠的 KV 存储系统，可以快速进行云配置。由 CoreOS 开发并维护键值存储系统，它使用Go语言编写，并通过 Raft 一致性算法处理日志复制以保证强一致性。</p><p>项目链接：<a href="https://github.com/coreos/etcd">https://github.com/coreos/etcd</a></p><h3 id="5-beego"><a href="#5-beego" class="headerlink" title="5) beego"></a>5) beego</h3><p>beego 是一个类似 <a href="http://c.biancheng.net/python/">Python</a> 的 Tornado 框架，采用了 RESTFul 的设计思路，使用Go语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架。</p><p>项目链接：<a href="https://github.com/astaxie/beego">https://github.com/astaxie/beego</a></p><h3 id="6-martini"><a href="#6-martini" class="headerlink" title="6) martini"></a>6) martini</h3><p>一款快速构建模块化的 Web 应用的Go语言框架。</p><p>项目链接：<a href="https://github.com/go-martini/martini">https://github.com/go-martini/martini</a></p><h3 id="7-codis"><a href="#7-codis" class="headerlink" title="7) codis"></a>7) codis</h3><p>国产的优秀分布式 <a href="http://c.biancheng.net/redis/">Redis</a> 解决方案。可以将 <code>codis</code> 理解成为 Web 服务领域的 <code>Nginx</code>，它实现了对 <code>Redis</code> 的反向代理和负载均衡。</p><p>项目链接：<a href="https://github.com/CodisLabs/codis">https://github.com/CodisLabs/codis</a></p><h3 id="8-delve"><a href="#8-delve" class="headerlink" title="8) delve"></a>8) delve</h3><p>Go语言强大的调试器，被很多集成环境和编辑器整合。</p><p>项目链接：<a href="https://github.com/derekparker/delve">https://github.com/derekparker/delve</a></p>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言简介</title>
    <link href="/2022/08/04/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/08/04/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Go语言简介"><a href="#Go语言简介" class="headerlink" title="Go语言简介"></a>Go语言简介</h1><p><code>Go</code>语言（或<code>Golang</code>）起源于 2007 年，并在 2009 年正式对外发布。<code>Go</code>是非常年轻的一门语言，它的主要目标是“兼具 <a href="http://c.biancheng.net/python/">Python</a> 等动态语言的开发速度和 C&#x2F;<a href="http://c.biancheng.net/cplus/">C++</a> 等编译型语言的性能与安全性”。</p><p><code>Go</code>语言是编程语言设计的又一次尝试，是对类<code>C</code>语言的重大改进，它<strong>不但能让你访问底层操作系统</strong>，还<strong>提供了强大的网络编程和并发编程支持</strong>。Go语言的用途众多，可以进行<strong>网络编程、系统编程、并发编程、分布式编程</strong>。</p><p><code>Go</code>语言的推出，旨在<strong>不损失应用程序性能的情况下降低代码的复杂性</strong>，具有“<strong>部署简单、并发性好、语言设计良好、执行性能好</strong>”等优势，目前国内诸多 IT 公司均已采用<code>Go</code>语言开发项目。</p><p><code>Go</code>语言有时候被描述为“**<code>C</code> 类似语言**”，或者是“21 世纪的<code>C</code>语言”。<code>Go</code>从<code>C</code>语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。</p><p>因为<code>Go</code>语言<strong>没有类和继承</strong>的概念，所以它和 <a href="http://c.biancheng.net/java/">Java</a> 或<code>C++</code>看起来并不相同。但是它通过接口（<code>interface</code>）的概念来实现多态性。<code>Go</code>语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说**<code>Go</code>语言是一门混合型的语言**。</p><p>此外，很多重要的开源项目都是使用<code>Go</code>语言开发的，其中包括<a href="http://c.biancheng.net/docker/">Docker</a>、Go-Ethereum、Thrraform 和 Kubernetes。</p><h2 id="Go语言创始人"><a href="#Go语言创始人" class="headerlink" title="Go语言创始人"></a>Go语言创始人</h2><p>对语言进行评估时，明白设计者的动机以及语言要解决的问题很重要。Go语言出自 Ken Thompson 和 Rob Pike、Robert Griesemer 之手，他们都是计算机科学领域的重量级人物。</p><h4 id="1-Ken-Thompson"><a href="#1-Ken-Thompson" class="headerlink" title="1) Ken Thompson"></a>1) Ken Thompson</h4><p>贝尔实验室 Unix 团队成员，C语言、Unix 和 Plan 9 的创始人之一，在 20 世纪 70 年代，设计并实现了最初的 UNIX 操作系统，仅从这一点说，他对计算机科学的贡献怎么强调都不过分。他还与 Rob Pike 合作设计了 UTF-8 编码方案。</p><h4 id="2-Rob-Pike"><a href="#2-Rob-Pike" class="headerlink" title="2) Rob Pike"></a>2) Rob Pike</h4><p>Go语言项目总负责人，贝尔实验室 Unix 团队成员，除帮助设计 UTF-8 外，还帮助开发了分布式多用户操作系统 Plan 9、Inferno 操作系统和 Limbo 编程语言，并与人合著了《The Unix Programming Environment》，对 UNIX 的设计理念做了正统的阐述。</p><h4 id="3-Robert-Griesemer"><a href="#3-Robert-Griesemer" class="headerlink" title="3) Robert Griesemer"></a>3) Robert Griesemer</h4><p>就职于 Google，参与开发 Java HotSpot 虚拟机，对语言设计有深入的认识，并负责 Chrome 浏览器和 Node.js 使用的 Google V8 <a href="http://c.biancheng.net/js/">JavaScript</a> 引擎的代码生成部分。</p><p>这些计算机科学领城的重量级人物设计Go语言的初衷是满足 Google 的需求。设计此语言花费了两年的时间，融入了整个团队多年的经验及对编程语言设计的深入认识。设计团队借鉴了 Pascal、Oberon 和C语言的设计智慧，同时<strong>让Go语言具备动态语言的便利性</strong>。因此，Go语言体现了经验丰富的计算机科学家的语言设计理念，是为全球最大的互联网公司之一设计的。</p><p>Go语言的所有设计者都说，设计Go语言是因为 C++ 给他们带来了挫败感。在 Google I&#x2F;O 2012 的 Go 设计小组见面会上，Rob Pike 是这样说的：</p><blockquote><p>我们做了大量的 C++ 开发，厌烦了等待编译完成，尽管这是玩笑，但在很大程度上来说也是事实。</p></blockquote><h2 id="Go是编译型语言"><a href="#Go是编译型语言" class="headerlink" title="Go是编译型语言"></a>Go是编译型语言</h2><p>Go <strong>使用编译器来编译代码</strong>。<strong>编译器将源代码编译成二进制（或字节码）</strong>格式；在编译代码时，编译器检查错误、优化性能并输出可在不同平台上运行的二进制文件。要创建并运行 Go 程序，程序员必须执行如下步骤。</p><ol><li>使用文本编辑器创建 Go 程序；</li><li>保存文件；</li><li>编译程序；</li><li>运行编译得到的可执行文件。</li></ol><p>这<strong>不同于 Python、Ruby 和 JavaScript 等语言，它们不包含编译步骤</strong>。<strong>Go 自带了编译器，因此无须单独安装编译器</strong>。</p><h2 id="为什么要学习Go语言"><a href="#为什么要学习Go语言" class="headerlink" title="为什么要学习Go语言"></a>为什么要学习Go语言</h2><p>如果你要<strong>创建系统程序，或者基于网络的程序</strong>，Go语言是很不错的选择。作为一种相对较新的语言，它是由经验丰富且受人尊敬的计算机科学家设计的，旨在应对创建大型并发网络程序面临的挑战。</p><p>在Go语言出现之前，开发者们总是面临非常艰难的抉择，<strong>究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java）</strong>，<strong>或者说开发难度较低但执行速度一般的动态语言呢</strong>？显然，<strong>Go语言在这 3 个条件之间做到了最佳的平衡</strong>：<strong>快速编译，高效执行，易于开发</strong>。</p><p>Go语言<strong>支持交叉编译</strong>，比如说你可以在运行 Linux 系统的计算机上开发可以在 Windows 上运行的应用程序。这是<strong>第一门完全支持 UTF-8 的编程语言</strong>，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go语言做到了真正的国际化！</p><h2 id="Go语言吉祥物"><a href="#Go语言吉祥物" class="headerlink" title="Go语言吉祥物"></a>Go语言吉祥物</h2><p>Go语言有一个吉祥物，在会议、文档页面和博文中，大多会包含下图所示的 Go Gopher，这是才华横溢的插画家 Renee French 设计的，她也是 Go 设计者之一 Rob Pike 的妻子。</p><p><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/1-1PPQA9545W.jpg" alt="Go语言吉祥物Gopher"></p>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一文详细理解IssS、PaaS、SaaS、KaaS等</title>
    <link href="/2022/08/03/%E4%B8%80%E6%96%87%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3IssS%E3%80%81PaaS%E3%80%81SaaS%E3%80%81KaaS%E7%AD%89/"/>
    <url>/2022/08/03/%E4%B8%80%E6%96%87%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3IssS%E3%80%81PaaS%E3%80%81SaaS%E3%80%81KaaS%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一文详细理解IaaS、PaaS、SaaS、KaaS等"><a href="#一文详细理解IaaS、PaaS、SaaS、KaaS等" class="headerlink" title="一文详细理解IaaS、PaaS、SaaS、KaaS等"></a>一文详细理解IaaS、PaaS、SaaS、KaaS等</h1><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p>要理解这三个概念，首先就需要理解什么是云计算</p><p>关于云计算的通用定义如下：</p><blockquote><p>云计算是一种<strong>按使用量付费的模式</strong>。这种模式提供<strong>可用的、便捷的、按需的</strong>网络访问， 进入<strong>可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务）</strong>，这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p></blockquote><p>换句话说通俗的理解其实就是：</p><blockquote><p>所谓<strong>云化就是把每个人手中独立的资源集中起来，放在一个地方进行统一管理，然后再动态的分配给每个人使用</strong>；而<strong>云计算就是把计算资源集中起来，按需使用，动态分配给需要使用的人进行使用，这个计算资源，包括CPU、内存、硬盘等硬件还有软件</strong>。</p></blockquote><div align="center"><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/1620.jpeg" alt="img" style="zoom:67%;"></div><p>云计算就是让用户通过互联网来使用在云端的<strong>应用</strong>、<strong>数据</strong>或者<strong>服务</strong>。</p><div align="center"><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/1620-16595082821613.jpeg" alt="img" style="zoom:80%;"></div><p>那么在云计算的结构中，这些资源是如何提供的呢？就要引出如下的介绍</p><h2 id="传统云计算结构"><a href="#传统云计算结构" class="headerlink" title="传统云计算结构"></a>传统云计算结构</h2><p>IaaS -&gt; PaaS -&gt; SaaS</p><h3 id="什么是IaaS"><a href="#什么是IaaS" class="headerlink" title="什么是IaaS"></a>什么是IaaS</h3><p><strong>基础设施即服务 (<code>IaaS</code>)</strong> ：为云服务<strong>提供硬件</strong>，其中<strong>包括服务器、网络和存储</strong>。对于那些<strong>不想购买和维护基础设施的企业</strong>，这便是一个可以大大降低成本的战略。</p><p>常见示例如：亚马逊<code>AWS</code>、谷歌计算引擎、阿里云、腾讯云和微软<code>Azure</code>等。</p><h3 id="什么是PaaS"><a href="#什么是PaaS" class="headerlink" title="什么是PaaS"></a>什么是PaaS</h3><blockquote><p>A system that abstracts away hardware and software deployment,enabling developers to simply mix and match components for application creation.<br>一个针对开发人员的应用开发平台，抽象并解耦了硬件资源和软件部署，使开发人员能够依赖平台公共的组件和服务，简单快速的完成应用开发</p></blockquote><p><strong>平台即服务 (<code>PaaS</code>)</strong> ：除了提供<code>IaaS</code>可提供的<strong>所有硬件</strong>之外，还提供<strong>操作系统和数据库</strong>。</p><p>常见示例如：<code>AWS Elastic Beanstalk</code>和谷歌应用程序引擎等。</p><p><code>PaaS</code>可以提供丰富的应用的目录，开发者只要把这些堆栈组合起来，就可以快速的完成应用的开发。</p><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/image-20220803150521625.png" alt="image-20220803150521625" style="zoom: 50%;"><p>但是开发者一旦想要自定义很多的东西就会受到<code>PaaS</code>的制约</p><h3 id="什么是SaaS"><a href="#什么是SaaS" class="headerlink" title="什么是SaaS"></a>什么是SaaS</h3><p><strong>软件即服务 (<code>SaaS</code>)</strong> ：<strong>提供了最多的支持</strong>，即为您的最终用户<strong>提供除其数据之外的所有服务</strong>。<code>SaaS</code><strong>可以在多租户架构中</strong>运行，软件的<strong>一个实例可以为多个用户提供服务</strong>，<code>SaaS</code>产品<strong>一般不需要下载安装</strong>，并且对于企业用户来说，<strong>不需要管理软件的更新</strong>，他们<strong>只需要负责自己的数据即可</strong>。</p><p>常见示例如：基于云的文件存储（百度云网盘、腾讯微云等）和电子邮件等。</p><h3 id="一图通俗易懂解释IaaS、PaaS及SaaS"><a href="#一图通俗易懂解释IaaS、PaaS及SaaS" class="headerlink" title="一图通俗易懂解释IaaS、PaaS及SaaS"></a>一图通俗易懂解释IaaS、PaaS及SaaS</h3><p>以云厂商的视角为例（黄色）</p><div align="center"><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/image-20220722151934701.png" style="zoom:67%;"></div><p>我们可以注意到，对于<code>IaaS</code>(基础设施即服务)，一开始我们需要<strong>提供的只有硬件</strong>，即“成品材料”即可；而到了<code>PaaS</code>(平台即服务)，我们需要额外<strong>提供操作系统及数据库</strong>，也就是“成品材料以及处理材料的东西”；到了<code>SaaS</code>(软件即服务)，我们需要<strong>提供全部东西</strong>，用户只需要来拿走成品“披萨”即可；为此，我们可以看到，<strong>用户的方便性也在逐步的提升</strong>。</p><h2 id="新型云计算结构"><a href="#新型云计算结构" class="headerlink" title="新型云计算结构"></a>新型云计算结构</h2><p>IaaS -&gt; KaaS -&gt; PaaS -&gt; SaaS</p><h3 id="KaaS"><a href="#KaaS" class="headerlink" title="KaaS"></a>KaaS</h3><blockquote><p>A system that enables developers to deploy and&#x2F;or manage Kubernetes clusters in a self-service manner.<br>可以让一个开发者通过自服务的形式去管理（跨云部署[裸机or私有云or公有云]、生命周期管理[扩容、缩容、基础组件的升级等]）他自己的自服务的集群</p></blockquote><ul><li>可以部署在不同的基础架构资源上，能对集群的生命周期进行管理</li><li>可以在其上去实现<code>PaaS</code>平台</li></ul><p>常见示例如：<code>Rancher</code>、<code>VMware Kubernetes Management Platform</code>、<code>Google Kubernetes Engine(GKE)</code>、<code>Tencent Kubernetes Engine(TKE)</code>、<code>Azure Kubernetes Service(AKS)</code>等</p><h4 id="Strength：Developer-control"><a href="#Strength：Developer-control" class="headerlink" title="Strength：Developer control"></a>Strength：Developer control</h4><ul><li>Developers can choose what applications they want</li><li>Developers can spin up what resources they need</li><li>Developers can upgrade&#x2F;update their clusters</li><li>Developers can control security</li></ul><p>相对来说，对于开发者来说具有更高的灵活性，更加支持应用在生产环境的使用，因为可控性更强<br>但是同时，矛与盾是对立存在的，对于开发者来说，这也带来了弱点</p><h4 id="Weakness：Developer-control"><a href="#Weakness：Developer-control" class="headerlink" title="Weakness：Developer control"></a>Weakness：Developer control</h4><ul><li>Developers can choose what applications they want</li><li>Developers can spin up what resources they need</li><li>Developers can upgrade&#x2F;update their clusters</li><li>Developers can control security</li></ul><p>对于开发者来说需要知道的更多（架构、技术原理），需要做的更多</p><h4 id="Strength：Vendor-neutrality"><a href="#Strength：Vendor-neutrality" class="headerlink" title="Strength：Vendor neutrality"></a>Strength：Vendor neutrality</h4><ul><li>Not reliant on any proprietary&#x2F;system specific API</li><li>Can be migrated to any other Kubernetes system&#x2F;provider</li><li>Can be used with multiple Kubernetes providers</li></ul><p><code>KaaS</code>不会被供应商锁定。因为当我们一旦深入的使用了某个平台，对于<code>PaaS</code>来说很难去进行架构的切换；但是<code>KaaS</code>在架构这个层面是由用户自己决定的。因此，如果你有很大的研发能力，需要真正的去运行一个应用在生产环境，可以去选择<code>KaaS</code>,他只需要去关心，我的应用和架构做好之后怎么部署在<code>Kubernetes</code>集群上，由<code>Kubernetes</code>去管理他的高可用，将来无论是<code>AKS</code>还是<code>TKE</code>都可以去切换使用。</p><h3 id="如何选择KaaS还是PaaS"><a href="#如何选择KaaS还是PaaS" class="headerlink" title="如何选择KaaS还是PaaS"></a>如何选择KaaS还是PaaS</h3><p>因为<code>KaaS</code>和<code>PaaS</code>其实是有点像的，所以当我们决定去使用<code>KaaS</code>还是<code>PaaS</code>的时候，可以问一下自己如下问题:</p><ul><li><p>What are you trying to accomplish with your automation?</p><p>如果是希望有自动化，来帮助你完成集群的管理，那么就可以选择带有<code>KaaS</code>功能的产品；</p></li><li><p>How much of a guardrail do your developers need&#x2F;want?</p><p>如果希望有一个灵活的or高度自定义的架构，那么<code>KaaS</code>平台更适合你；如果希望开发者能快速的部署业务，那么<code>PaaS</code>平台更适合</p></li><li><p>How are you going to handle upgrades&#x2F;updates?</p><p>这里<code>KaaS</code>和<code>PaaS</code>都可以去解决</p></li><li><p>How many tenants&#x2F;applications do you have?</p><p>如果租户or应用比较多，那么可以采用<code>PaaS</code>平台；如果租户只有比较重要的几个，比较少，希望他有更高的可靠性，那么就可以基于<code>KaaS</code>去部署不同的集群</p></li><li><p>How much flexibility do you need in choosing your architecture?</p></li><li><p>Do you anticipate needing different clouds?Multiple clouds?</p></li><li><p>How predictable are your plans?</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>云原生安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入之预编译</title>
    <link href="/2022/06/17/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    <url>/2022/06/17/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E9%A2%84%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入之预编译"><a href="#SQL注入之预编译" class="headerlink" title="SQL注入之预编译"></a>SQL注入之预编译</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们都知道注入攻击常年霸占OWASP TOP10的绝对TOP 1，那么SQL注入在其中又是首当其冲。那么要预防SQL注入除了最常见的<strong>转义、过滤、拦截敏感字符</strong>外，安全从业者比较推荐的还有<strong>预编译</strong>的方法。那么本文将围绕预编译是什么？为什么预编译可以预防SQL注入？预编译真的能够完全防止SQL注入吗？这三个问题为主要切入点进行关于SQL注入预编译相关的介绍和讨论。</p></blockquote><h2 id="预编译介绍"><a href="#预编译介绍" class="headerlink" title="预编译介绍"></a>预编译介绍</h2><h3 id="什么是预编译"><a href="#什么是预编译" class="headerlink" title="什么是预编译"></a>什么是预编译</h3><p>SQL预编译其实就是一种分离数据（用户输入的数据）和代码（SQL指令）的一种方式，通俗的来说其实就是提前告诉SQL语法处理器，将未拼接参数的SQL语句提前进行声明和编译，然后将所有用户的输入视为纯字符参数传递给数据库，最后再组成查询语句去进行查询。此时，传递的参数就不会再被当作指令去进行执行了，只会当作普通的文本，也就达到了防止SQL注入的目的。</p><p>java中预编译操作流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建数据库连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc.mysql://localhost:3306/test?useUnicode=true&amp;charset=utf-8&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//2.将没有参数的SQL语句进行预编译(用?作为占位符)</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span>  conn.prepareStatement(<span class="hljs-string">&quot;select * from users where username=? and password=?&quot;</span>);<br><span class="hljs-comment">//3.设置参数</span><br>state.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;myusername&quot;</span>);<br>state.setString(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;mypassword&quot;</span>);<br><span class="hljs-comment">//4.执行sql语句</span><br><span class="hljs-type">Resultset</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> state.executeQuery();<br></code></pre></td></tr></table></figure><h3 id="预编译防止SQL注入的原因"><a href="#预编译防止SQL注入的原因" class="headerlink" title="预编译防止SQL注入的原因"></a>预编译防止SQL注入的原因</h3><p>刚才粗略的介绍了预编译能够防止SQL注入的原因，接下来从本质上分析一下为什么预编译能够防止SQL注入。</p><p>以MySQL为例，先介绍一下预编译的运行机制。在MySQL中一条SQL语句从传入到执行往往经历：检查缓存、规则验证、解析器解析为语法树、预处理器进一步验证语法树、优化SQL、生成执行计划、执行等步骤。其中对于语法的解析和优化过程其实是与传入的字段值无关的，但却比真正执行的过程更为耗费时间，因此在处理某些语句时，很容易造成时间的浪费，效率的下降，如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select *<span class="hljs-keyword">from</span> cloudcrowd <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>;<br>select *<span class="hljs-keyword">from</span> cloudcrowd <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>这两个语句由于后面的id值的不同，因此在检查缓存阶段就不会匹配，就不会得到重用，后面的所有阶段都要再依次进行，但是他们的语法树却是相似的，仅仅是id字段的值不同，因此如果每次都从检查缓存阶段重新开始，解析构造语法树就会造成极大的时间浪费。</p><p><img src="/.com//Xbr9jP.png" alt="语法树"></p><p>预编译的话会使用占位符?来代替字段值的部分，将SQL语句先交由数据库去进行预处理，构建语法树，再传入真正的字段值去进行多次执行，这样就会省略了重复解析和优化相同语法树的时间，提升了SQL执行的效率。</p><p>于是在传入字段值之前，由于语法树已经提前构造好了，因此无论传入任何字段值，都无法再更改语法树的结构。至此，任何传入的值都只会被当作值来看待，就不会再出现非预期的查询，这也就是预编译能够防止SQL注入的根本原因。</p><h3 id="使用了预编译就一定是安全了吗"><a href="#使用了预编译就一定是安全了吗" class="headerlink" title="使用了预编译就一定是安全了吗"></a>使用了预编译就一定是安全了吗</h3><p>并不会，主要有以下几种情况。无论什么时候，安全问题的产生往往就是两方面的因素：技术和人</p><h4 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h4><p>首先来说技术方面，预编译机制往往也会存在一些局限性。</p><h5 id="like语句"><a href="#like语句" class="headerlink" title="like语句"></a>like语句</h5><p>查询过程中我们有些时候会使用到like语句，比如查询名字中带有“高”的用户，我们可能会采取如下语句进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%高%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>此时，如果传入的参数为<code>%</code>，执行语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%%%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这种情况下预编译是可以通过的，会返回所有的用户</p><p><img src="/.com//image-20220617151352145.png" alt="image-20220617151352145"></p><h5 id="表名列名无法预编译"><a href="#表名列名无法预编译" class="headerlink" title="表名列名无法预编译"></a>表名列名无法预编译</h5><p>有代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$pdo</span>-&gt;<span class="hljs-title function_ invoke__">prepare</span>(<span class="hljs-string">&quot;select *from ? where id=?&quot;</span>);<br></code></pre></td></tr></table></figure><p>上面这段代码是错误的，因为表名和列名是不能够被预编译的，这是因为在生成语法树的过程中，预处理器在进一步检查解析后的语法树时，会检查数据表和数据列是否存在，因此数据表和数据列不能被占位符<code>?</code>所替代。</p><p>但在很多业务场景中，表名需要作为一个变量存在，因此这部分需要由+进行SQL语句的拼接，若表名是由外部传入并且可控的，那么就仍然会造成SQL注入。</p><p>同理，<code>order by</code>后的<code>ASC/DESC</code>也不能够被预编译，因此当业务场景涉及到用户可控制排序方式，且<code>ASC/DESC</code>是由前台传入并拼接到<code>SQL</code>语句上时，就也可能会出现危险了。</p><h6 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h6><p>可以在程序内部创建需要用到的表名的集合，每次查询时从集合中选出，由此避免表名被篡改，<code>ASC/DESC</code>也应在做严格检查后再拼接，最好不要由前台传入。任何的拼接都有可能出现问题，总体来说，正确的使用预编译还是可以杜绝SQL注入攻击的。</p><h5 id="动态传入的表名列名等"><a href="#动态传入的表名列名等" class="headerlink" title="动态传入的表名列名等"></a>动态传入的表名列名等</h5><p>java中如果使用<code>myhabtis</code>作为持久化框架，在<code>mapper.xml</code>中,如果入参使用<code>#</code>传值会使用预编译机制。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;query&quot;</span>&gt;</span><br>   select * from user<br>   <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>     name = #&#123;name&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但存在特殊情况，即动态传入列名和表名时会报错。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderBy&quot;</span>&gt;</span><br>   order by $&#123;sortString&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>sortString字段的内容是一个方法中动态计算出来的，这种情况是没法用<code>#</code>，代替<code>$</code>的，这样程序会报错，也就无法自动触发使用预编译机制。需要我们在服务端加入单独的过滤机制。</p><h3 id="人的方面"><a href="#人的方面" class="headerlink" title="人的方面"></a>人的方面</h3><p>预编译机制在理论上确实可以极大程度的避免SQL注入的发生，除了上述提到的特定场景下预编译机制有可能会失效外，其实还有要求就是<strong>应确保开发人员要正确的使用预编译</strong>，在代码审计中曾经发现过有些开发者虽然是使用了预编译机制，但是参数值仍然是由+拼接上去的，而不是正确的使用参数绑定，这样也就仍可以造成SQL注入。</p><h3 id="预编译的优点"><a href="#预编译的优点" class="headerlink" title="预编译的优点"></a>预编译的优点</h3><ol><li><p>可以提高访问数据库的性能</p><p>我们知道数据库在处理SQL语句时有一个预编译的过程，而预编译对象就是把一些格式固定的SQL语句编译之后，存放在内存池中（也就是数据库缓冲池），当我们再次执行相同的SQL语句时就不再需要预编译的过程了，只需要DBMS去运行SQL语句即可。</p><p>所以当你<font color="green">需要执行Statement对象多次的时候，PreparedStatement对象将会大大降低运行时间</font>，特别是大型数据库中，它可以有效地也加快了访问数据库的速度。（<a href="https://blog.csdn.net/weixin_43896929/article/details/122293768">关于Statement和PreparedStatement的介绍</a>&gt;）</p></li><li><p>可以防止SQL注入</p><p>使用预编译后，其后注入的参数将不会再进行SQL编译。也就是说<strong>其后注入进来的参数，系统将不会认为它会是一条SQL语句，而默认其是一个参数，参数中的 or 或者 and 等就不是SQL语法保留字了</strong>。</p></li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote><p><a href="https://blog.csdn.net/qq_43936524/article/details/115104527">https://blog.csdn.net/qq_43936524/article/details/115104527</a></p><p><a href="http://cn-sec.com/archives/246187.html">http://cn-sec.com/archives/246187.html</a></p><p><a href="https://blog.csdn.net/Just__2009/article/details/109126437?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-109126437-blog-123122623.pc_relevant_blogantidownloadv1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-109126437-blog-123122623.pc_relevant_blogantidownloadv1&amp;utm_relevant_index=1">https://blog.csdn.net/Just__2009/article/details/109126437?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-109126437-blog-123122623.pc_relevant_blogantidownloadv1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-109126437-blog-123122623.pc_relevant_blogantidownloadv1&amp;utm_relevant_index=1</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>任意文件下载漏洞原理解析</title>
    <link href="/2022/05/30/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    <url>/2022/05/30/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="任意文件下载漏洞原理解析"><a href="#任意文件下载漏洞原理解析" class="headerlink" title="任意文件下载漏洞原理解析"></a>任意文件下载漏洞原理解析</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>这种漏洞只有在获取到网站的管理员权限，进入到网站的管理才有可能会出现。</p><p>如果通过信息收集dirsearch或御剑，下载到网站的源码或备份文件也是属于任意文件下载漏洞。</p></blockquote><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>许多网站都会开放下载文件的功能，但是由于<strong>下载功能代码处对下载文件类型、目录未做限制或限制不当</strong>，<strong>导致攻击者可下载服务器任意文件</strong>。(例如：数据库配置文件<code>db.php</code>、<code>config.php</code>等) </p><p>某些文件下载功能实现过程是：<strong>根据参数filename的值，获得该文件在网站上的绝对路径，读取文件，然后直接发送给客户端下载</strong>。开发者如果没有对传入的参数<code>filename</code>进行过滤，攻击者就可以利用该漏洞下载服务器上任何文件，于是就产生<strong>任意文件下载漏洞</strong>。</p><p>某个实际下载过程如下：</p><p><img src="https://s1.ax1x.com/2022/05/30/X1aqfg.png" alt="img"></p><p>我们如果将path后面的路径修改为<code>/etc/passwd</code>,那么我们是不是就可以下载到其他文件了呢？</p><p><img src="https://s1.ax1x.com/2022/05/30/X1dihF.png" alt="image 20220530111907363"></p><p>这个漏洞产生的<strong>核心原理</strong>就是：<strong>下载的参数是用户可控的，并不是写死的</strong>，于是就产生了任意文件下载漏洞。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ol><li>任意文件下载漏洞正常的利用手段是<strong>下载服务器文件</strong>，如脚本代码、服务器配置文件或者是系统配置文件等。</li><li>但是有的时候我们可能根本就不知道网站所处的环境，以及网站的路径，这时候我们只能利用<code>./ ../</code>来逐层猜测路径。</li></ol><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ol><li>下载服务器上的任意文件，如：脚本代码、服务及系统配置文件等</li><li>对下载得到的代码，进行进一步代码审计，得到更多可利用的漏洞。</li></ol><h3 id="寻找方式"><a href="#寻找方式" class="headerlink" title="寻找方式"></a>寻找方式</h3><p>1、Google hack语法利用</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">inurl:</span><span class="hljs-string">&quot;readfile.php?file=&quot;</span><br></code></pre></td></tr></table></figure><p>2、从链接上看</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>download.php?path=<br><span class="hljs-bullet">- </span>download.php?file=<br><span class="hljs-bullet">- </span>down.php?file=<br><span class="hljs-bullet">- </span>data.php?file=<br><span class="hljs-bullet">- </span>readfile.php?file=<br><span class="hljs-bullet">- </span>read.php?filename=<br></code></pre></td></tr></table></figure><p>3、从参数名看</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso">- $RealPath=<br>- $FilePath=<br>- $filepath=<br>- $Filepath=<br>- $Path=<br>- $path=<br>- $inputFile=<br>- $Inputfile=<br>- $url=<br>- $urls=<br>- <span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><h2 id="二、漏洞利用"><a href="#二、漏洞利用" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h2><blockquote><p>利用任意文件下载漏洞，我们就可以读取服务器上常规的配置文件、下载各种<code>.log</code>文件， 也可以尝试读取<code>/root/.bash_history</code>看自己是否具有<code>root</code>权限、读取<code>mysql</code>下的<code>bash_history</code>文件等。</p></blockquote><p>因为很多时候我们打进内网之后没有办法进行其余操作了，那么我们就可以尝试用<code>history</code>命令或读取查看<code>/root/.bash_history</code>和<code>/root/.mysql_history</code>来尝试查看一下曾经别人执行过的命令，我们就有可能看到有的人执行过的一些敏感操作。</p><p>例如：有的人如果执行过一些文件操作，那么我们就有可能进而摸索出网站的系统文件结构是什么样的；还有有的人可能会执行过一些改密码的操作，我们同样可以得到用户的密码等。</p><p><img src="https://s1.ax1x.com/2022/05/30/X1dGjA.png" alt="image 20220530130534000"></p><p>另外，在linux中有这样一个命令<code> locate</code>，它可以用来查找文件或目录，它并不是从具体目录进行搜索，而是搜索一个数据库:<code>/var/lib/mlocate/mlocate.db</code>。<br>这个数据库中含有本地所有文件信息，而且Linux系统会自动创建这个数据库，并且每天自动更新1次。</p><p>例如：读取<code>mlocate.db</code>文件内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/mlocate/m</span>locate.db<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/05/30/X1dNHP.png" alt="image 20220530131130521"></p><p>其中包含了特别多的文件内容</p><p>于是我们就可以利用任意文件下载漏洞将<code>mlocate.db</code>文件下载下来，然后利用<code>locate</code>命令将数据输出成文件，这里面包含了全部的文件路径信息。</p><p><strong>例：利用locate命令读取包含admin内容的全部路径</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">locate mlocate<span class="hljs-meta">.db</span> admin<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/05/30/X1dsjs.png" alt="image 20220530131411153"></p><p>因此利用这个命令我们可以将<code>mlocate.db</code>内所有包含<code>admin</code>内容全部输出出来，利用<code>mlocate.db</code>这个文件我们就可以获取到该服务器上任何攻击者想要的内容，并针对性的下载下来，从而不用一个个猜解目录，但是这个文件只有<code>root</code>用户才可以读取。</p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><p><strong>常见敏感文件</strong></p><p>系统都存在的文件，用来验证漏洞是否存在</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Windows:</span><br><span class="hljs-symbol">C:</span>\boot.ini <span class="hljs-comment">//查看系统版本</span><br><span class="hljs-symbol">C:</span>\Windows\System32\inetsrv\MetaBase.xml <span class="hljs-comment">//IIS配置文件</span><br><span class="hljs-symbol">C:</span>\Windows\repair\sam <span class="hljs-comment">//存储系统初次安装的密码</span><br><span class="hljs-symbol">C:</span>\Program Files\mysq1\my.ini <span class="hljs-comment">//Mysql配置</span><br><span class="hljs-symbol">C:</span>\Program Files\mysql\data\mysq1\user.MYD <span class="hljs-comment">//Mysql root</span><br><span class="hljs-symbol">C:</span>\Windows\php.ini <span class="hljs-comment">//php配置信息</span><br><span class="hljs-symbol">C:</span>\Windows\my.ini <span class="hljs-comment">//Mysql配置信息</span><br><span class="hljs-symbol">C:</span>\Windows\win.ini <span class="hljs-comment">//Windows 系统的一个基本系统配置文件</span><br><br></code></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Linux:</span><br><span class="hljs-keyword">/root/</span>.ssh/authorized keys<br><span class="hljs-keyword">/root/</span>.ssh/id_rsa<br><span class="hljs-keyword">/root/</span>.ssh/id_ras.keystore<br><span class="hljs-keyword">/root/</span>.ssh/known_hosts <span class="hljs-comment">//记录每个访问计算机用户的公钥</span><br><span class="hljs-keyword">/etc/</span>passwd<br><span class="hljs-keyword">/etc/</span>shadow<br><span class="hljs-keyword">/etc/</span>my.cnf <span class="hljs-comment">//mysql配置文件</span><br><span class="hljs-keyword">/etc/</span>httpd<span class="hljs-keyword">/conf/</span>httpd.conf <span class="hljs-comment">//apache配置文件</span><br><span class="hljs-keyword">/root/</span>.bash_history <span class="hljs-comment">//用户历史命令记录文件</span><br><span class="hljs-keyword">/root/</span>.mysql_history <span class="hljs-comment">//mysql历史命令记录文件</span><br>......<br></code></pre></td></tr></table></figure><p><strong>漏洞格式</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">index.php?f=../../../../../etc/passwd<br>index.php?f=../index.php<br>index.php?f=file:<span class="hljs-comment">///etc/passwd</span><br></code></pre></td></tr></table></figure><blockquote><p>注：当参数f的值为php文件时，若是文件被解析则是文件包含漏洞，若是显示的是文件源码或者提示下载，则是任意文件查看或下载漏洞。</p></blockquote><h2 id="三、靶场演练"><a href="#三、靶场演练" class="headerlink" title="三、靶场演练"></a>三、靶场演练</h2><h3 id="以pikachu靶场为例："><a href="#以pikachu靶场为例：" class="headerlink" title="以pikachu靶场为例："></a>以pikachu靶场为例：</h3><p>打开靶场我们首先看到的是对于任意文件下载靶场的介绍：</p><p><img src="https://s1.ax1x.com/2022/05/30/X1dREV.png" alt="image 20220530163836514"></p><p>然后我们进入靶场，开始实战</p><p>靶场给了一堆图片说是我们可以进行下载</p><p><img src="https://s1.ax1x.com/2022/05/30/X1d4CF.png" alt="image 20220530163940505"></p><p>那么我们就点击第一个图片科比进行下载尝试（利用Burp抓包）：</p><p><img src="https://s1.ax1x.com/2022/05/30/X1dov9.png" alt="image 20220530164026702"></p><p>点击之后我们注意到数据包里有一个十分敏感的传参<code>?filename=kb.png</code>,那么这个传参会不会就决定了我们下载哪个文件呢？</p><p><img src="https://s1.ax1x.com/2022/05/30/X1wSvd.png" alt="image 20220530164130565"></p><p>我们在点击第二个图片下载抓包查看</p><p><img src="https://s1.ax1x.com/2022/05/30/X1wkUf.png" alt="image 20220530164245316"></p><p>我们注意到这时候文件的传参值变为了<code>ai.png</code></p><p><img src="https://s1.ax1x.com/2022/05/30/X1wkUf.png" alt="image 20220530164245316"></p><p>那么我们是不是就可以尝试下修改第一个传参值为第二个文件名，看看是否能下载下来，如果能下载下来，那么久存在任意文件下载漏洞。</p><p>于是我们继续抓包修改传参值</p><p><img src="https://s1.ax1x.com/2022/05/30/X1w1aV.png" alt="image 20220530164508445"></p><p>然后我们发现我们成功的下载下来了ai.png这个文件，于是也就说明这里存在任意文件下载漏洞。</p><p><img src="https://s1.ax1x.com/2022/05/30/X1wdq1.png" alt="image 20220530164607126"></p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>很多时候我们进行尝试的时候，对方可能会有检测，针对任意文件下载可能更多的是针对于<code>../</code>进行一个检测，于是我们可以尝试对<code>../</code>进行一个变形，并利用URL编码的方式尝试一个绕过。</p><p><strong>常见URL编码绕过技术</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-variable">%2</span>e<span class="hljs-variable">%2</span>e<span class="hljs-variable">%2</span>f 等于 ../<br><span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/ 等于 ../<br>..<span class="hljs-variable">%2</span>f 等于 ../<br><span class="hljs-variable">%2</span>e<span class="hljs-variable">%2</span>e<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span> 等于 ..\<br>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span> 等于 ..\<br><span class="hljs-variable">%252</span>e<span class="hljs-variable">%252</span>e<span class="hljs-variable">%252</span>f 等于 ../<br>..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af../  等于 ../../   （％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af是<span class="hljs-string">&quot;/&quot;</span>字符的非法 UTF－<span class="hljs-number">8</span>表示方式）<br></code></pre></td></tr></table></figure><p>例如：(替换后)</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/<span class="hljs-variable">%2</span>e<span class="hljs-variable">%e</span>/boot.ini<br>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>..<span class="hljs-variable">%5</span><span class="hljs-keyword">c</span>/boot.ini<br>..<span class="hljs-variable">%2</span>f..<span class="hljs-variable">%2</span>f..<span class="hljs-variable">%2</span>f..<span class="hljs-variable">%2</span>f..<span class="hljs-variable">%2</span>f..<span class="hljs-variable">%2</span>fetc/passwd<br>..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af/../..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af/../..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af/../..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af/../..％<span class="hljs-keyword">c</span><span class="hljs-number">0</span>％af/../boot.ini<br></code></pre></td></tr></table></figure><p><strong>其他绕过技术</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/../</span>.<span class="hljs-regexp">/../</span>.<span class="hljs-regexp">/../</span><br>............../<br>.\\\\..\\\\<br>... ...<br></code></pre></td></tr></table></figure><p><strong>其他特殊容器支持的编码</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm">..<span class="hljs-variable">%c1</span>(pc|af|<span class="hljs-number">9</span><span class="hljs-keyword">c</span>|<span class="hljs-number">1</span><span class="hljs-keyword">c</span>|<span class="hljs-number">8</span>s)<br>..<span class="hljs-variable">%c0</span>(af|<span class="hljs-number">9</span>v|qf|<span class="hljs-number">2</span>f|<span class="hljs-number">5</span><span class="hljs-keyword">c</span>)<br>..<span class="hljs-variable">%f8</span><span class="hljs-variable">%80</span><span class="hljs-variable">%80</span><span class="hljs-variable">%af</span><br>..<span class="hljs-variable">%e0</span><span class="hljs-variable">%80</span><span class="hljs-variable">%af</span><br>..<span class="hljs-variable">%u0025u005c</span><br><span class="hljs-variable">%c0</span><span class="hljs-variable">%ce</span><span class="hljs-variable">%c0</span><span class="hljs-variable">%ae</span><br><span class="hljs-variable">%c0.</span><span class="hljs-variable">%c0.</span><br>... ...<br></code></pre></td></tr></table></figure><h3 id="危害最大化"><a href="#危害最大化" class="headerlink" title="危害最大化"></a>危害最大化</h3><ol><li><p><strong>下载网站本身源代码</strong></p><p>自己本地搭建进行代码审计</p></li><li><p><strong>jsp站点</strong></p><p>​下载Tomcat的配置文件<code>tomcat-users.xml</code> (里面保存登录的用户名和密码)，<code>tomcat-users.xml</code>在<code>conf</code>文件夹下，这样就可以直接使用下载点下载该文件。然后使用账号密码登录Tomcat,上传war拿shell。<br>​网站的配置文件jsp的配置文件放在根目录<code>WEB-INF/Web.xml</code>下(一般都有很多内容,有时含有数据库连接用户名和密码等关键信息)。</p></li><li><p><strong>aspx站点</strong></p><p>​利用sqI server渗透。aspx站点用根目录下的<code>web.config</code>文件保存配置信息，下载<code>web.config</code>文件，打开配置文件找到数据库账号密码。然后通过报错获取网站绝对路径，然后连接数据库使用差异备份获得shell。</p><p>​下载dlI文件。Aspx站点一般都会对后台源代码进行编译封装，保存到dIl文件中，放到网站根目录的Bin文件夹下，因此，可以利用下载点下载dll文件，获得网站源代码(并不会很全) 。使用.net reflector工具打开编译后的dll文件，获得网站源代码。</p></li><li><p><strong>asp站点</strong></p><p>找到后台登陆入口，下载该登陆界面，找到数据库连接文件（在<code>inc/conn.asp</code>中），下载<code>conn.asp</code>文件，找到数据库路径，直接下载access数据库，找到管理员密码登陆后台，利用后台的上传功能，上传shell。</p></li><li><p><strong>php站点</strong></p><p>下载<code>config.php</code>获得mysql数据库的用户名和密码，登录phpMyAdmin，使用日志写shell。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>超级弱口令检测工具</title>
    <link href="/2020/10/01/%E8%B6%85%E7%BA%A7%E5%BC%B1%E5%8F%A3%E4%BB%A4%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/10/01/%E8%B6%85%E7%BA%A7%E5%BC%B1%E5%8F%A3%E4%BB%A4%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="超级弱口令检测工具"><a href="#超级弱口令检测工具" class="headerlink" title="超级弱口令检测工具"></a>超级弱口令检测工具</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在渗透测试中，针对各项服务（FTP、RDP、SSH 等）的爆破往往是繁琐的，一款好用的爆破工具，可以提高渗透测试的效率，超级弱口令检查工具（作者shac2）支持很多服务的爆破,支持批量导入爆破。</p><h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>SNETCracker 超级弱口令检查工具是一款Windows平台的弱口令审计工具，支持批量多线程检查，可快速发现弱密码、弱口令账号，密码支持和用户名结合进行检查，大大提高成功率，支持自定义服务端口和字典。</p><p>工具采用C#开发，需要安装.NET Framework 4.0，工具目前支持SSH、RDP、SMB、MySQL、SQLServer、Oracle、FTP、MongoDB、Memcached、PostgreSQL、Telnet、SMTP、SMTP_SSL、POP3、POP3_SSL、IMAP、IMAP_SSL、VNC、Redis 等服务的弱口令检查工作。</p><p>其他依赖：检查SSH需要安装 VC++2010 32位。</p><h4 id="2-目录介绍"><a href="#2-目录介绍" class="headerlink" title="2.目录介绍"></a>2.目录介绍</h4><p>工具目录下的三个文件夹分别是配置、字典和日志，一般情况下我们不需要修改配置，字典的话可以根据个人情况进行替换或者添加。</p><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/image-20230320100228840.png" alt="image-20230320100228840" style="zoom: 50%;"><p>dic 文件夹中包含了常用的字典，可以自行添加字典进行扩充</p><img src="/.com//image-20230320100913984.png" alt="image-20230320100913984" style="zoom:50%;"><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/shack2/</span>SNETCracker<span class="hljs-regexp">/releases/</span>tag/<span class="hljs-number">1.0</span>.<span class="hljs-number">20190715</span><br></code></pre></td></tr></table></figure><h2 id="二、工具使用"><a href="#二、工具使用" class="headerlink" title="二、工具使用"></a>二、工具使用</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>直接运行文件 SNETCracker.exe，运行后出现主界面图</p><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/image-20230320100840839.png" alt="image-20230320100840839" style="zoom:50%;"><h3 id="功能使用展示"><a href="#功能使用展示" class="headerlink" title="功能使用展示"></a>功能使用展示</h3><h4 id><a href="#" class="headerlink" title></a><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/image-20230320102956449.png" alt="image-20230320102956449" style="zoom: 67%;"></h4><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-邮箱弱口令"><a href="#1-邮箱弱口令" class="headerlink" title="1.邮箱弱口令"></a>1.邮箱弱口令</h4><p>检查邮箱弱口令时，部分邮箱系统需要填写邮箱后缀进行登录，如果检查邮箱出现一个账号都没有成功的情况，可以在账户后缀里面添加邮箱后缀在检查，例如（<code>@mail.baidu.com</code>）。</p><h4 id="2-SSH-检查注意事项"><a href="#2-SSH-检查注意事项" class="headerlink" title="2.SSH 检查注意事项"></a>2.SSH 检查注意事项</h4><p>① 某些SSH可能由于服务器没做SSH DNS 优化，单次登录要5-10秒时间，所以建议延时设置为大于10秒，否则可能因为超时无法检测。</p><p>② 当检查SSH出现异常时“Could not load file or assembly ‘ChilkatDotNet4.dll’ or one of its dependencies. 找不到指定的模块。”，请安装32位vc++ 2010。</p><h4 id="3-RDP检查注意事项"><a href="#3-RDP检查注意事项" class="headerlink" title="3.RDP检查注意事项"></a>3.RDP检查注意事项</h4><p>线程建议不要超过10个，否则容易崩溃。</p><h4 id="4-SMB检查"><a href="#4-SMB检查" class="headerlink" title="4.SMB检查"></a>4.SMB检查</h4><p>检查SMB服务一般需要开放445端口，如果需要检查域账号弱口令，需要在用户名前面加上“域名称\”。类似“dc\administrator”。</p><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/image-20230320103842064.png" alt="image-20230320103842064" style="zoom:67%;"><h4 id="5-RDP兼容问题"><a href="#5-RDP兼容问题" class="headerlink" title="5.RDP兼容问题"></a>5.RDP兼容问题</h4><p>为了RDP兼容更广，2019-03-23版本修改了RDP DLL版本，采用win7平台DLL，支持Win7或Server08以上系统使用，支持任意Windows操作系统的RDP登陆检查。之前版本由于连接加密问题只能支持server 03和部分Server 08。如果你要在Server 03或Xp上运行此工具，并且要使用RDP检查，请下载2019-03-22版本，2019-03-23以后版本，RDP不在支持。</p>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络安全法解读</title>
    <link href="/2020/09/01/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95%E8%A7%A3%E8%AF%BB/"/>
    <url>/2020/09/01/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="网络安全法解读"><a href="#网络安全法解读" class="headerlink" title="网络安全法解读"></a>网络安全法解读</h1><p><img src="https://typora-note--image.oss-cn-hangzhou.aliyuncs.com/img/image-20220810092729803.png"></p><h2 id="《中华人民共和国网络安全法》全文"><a href="#《中华人民共和国网络安全法》全文" class="headerlink" title="《中华人民共和国网络安全法》全文"></a>《中华人民共和国网络安全法》全文</h2><p><strong>中华人民共和国网络安全法<br>（2016年11月7日第十二届全国人民代表大会常务委员会第二十四次会议通过）</strong></p><h3 id="第一章-总-则"><a href="#第一章-总-则" class="headerlink" title="第一章　总　则"></a>第一章　总　则</h3><h4 id="第一条"><a href="#第一条" class="headerlink" title="第一条"></a>第一条</h4><p>为了保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展，制定本法。</p><h4 id="第二条"><a href="#第二条" class="headerlink" title="第二条"></a>第二条</h4><p>在中华人民共和国境内建设、运营、维护和使用网络，以及网络安全的监督管理，适用本法。</p><h4 id="第三条"><a href="#第三条" class="headerlink" title="第三条"></a>第三条</h4><p>国家坚持网络安全与信息化发展并重，遵循积极利用、科学发展、依法管理、确保安全的方针，推进网络基础设施建设和互联互通，鼓励网络技术创新和应用，支持培养网络安全人才，建立健全网络安全保障体系，提高网络安全保护能力。</p><h4 id="第四条"><a href="#第四条" class="headerlink" title="第四条"></a>第四条</h4><p>国家制定并不断完善网络安全战略，明确保障网络安全的基本要求和主要目标，提出重点领域的网络安全政策、工作任务和措施。</p><h4 id="第五条"><a href="#第五条" class="headerlink" title="第五条"></a>第五条</h4><p>国家采取措施，监测、防御、处置来源于中华人民共和国境内外的网络安全风险和威胁，保护关键信息基础设施免受攻击、侵入、干扰和破坏，依法惩治网络违法犯罪活动，维护网络空间安全和秩序。</p><h4 id="第六条"><a href="#第六条" class="headerlink" title="第六条"></a>第六条</h4><p>国家倡导诚实守信、健康文明的网络行为，推动传播社会主义核心价值观，采取措施提高全社会的网络安全意识和水平，形成全社会共同参与促进网络安全的良好环境。</p><h4 id="第七条"><a href="#第七条" class="headerlink" title="第七条"></a>第七条</h4><p>国家积极开展网络空间治理、网络技术研发和标准制定、打击网络违法犯罪等方面的国际交流与合作，推动构建和平、安全、开放、合作的网络空间，建立多边、民主、透明的网络治理体系。</p><h4 id="第八条"><a href="#第八条" class="headerlink" title="第八条"></a>第八条</h4><p>国家网信部门负责统筹协调网络安全工作和相关监督管理工作。国务院电信主管部门、公安部门和其他有关机关依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。</p><p>县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。</p><h4 id="第九条"><a href="#第九条" class="headerlink" title="第九条"></a>第九条</h4><p>网络运营者开展经营和服务活动，必须遵守法律、行政法规，尊重社会公德，遵守商业道德，诚实信用，履行网络安全保护义务，接受政府和社会的监督，承担社会责任。</p><h4 id="第十条"><a href="#第十条" class="headerlink" title="第十条"></a>第十条</h4><p>建设、运营网络或者通过网络提供服务，应当依照法律、行政法规的规定和国家标准的强制性要求，采取技术措施和其他必要措施，保障网络安全、稳定运行，有效应对网络安全事件，防范网络违法犯罪活动，维护网络数据的完整性、保密性和可用性。</p><h4 id="第十一条"><a href="#第十一条" class="headerlink" title="第十一条"></a>第十一条</h4><p>网络相关行业组织按照章程，加强行业自律，制定网络安全行为规范，指导会员加强网络安全保护，提高网络安全保护水平，促进行业健康发展。</p><h4 id="第十二条【重点关注】"><a href="#第十二条【重点关注】" class="headerlink" title="第十二条【重点关注】"></a><font color="red">第十二条【重点关注】</font></h4><p>国家保护公民、法人和其他组织依法使用网络的权利，促进网络接入普及，提升网络服务水平，为社会提供安全、便利的网络服务，保障网络信息依法有序自由流动。</p><p><strong>任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和其他合法权益等活动。</strong></p><h4 id="第十三条"><a href="#第十三条" class="headerlink" title="第十三条"></a>第十三条</h4><p>国家支持研究开发有利于未成年人健康成长的网络产品和服务，依法惩治利用网络从事危害未成年人身心健康的活动，为未成年人提供安全、健康的网络环境。</p><p>第十四条　任何个人和组织有权对危害网络安全的行为向网信、电信、公安等部门举报。收到举报的部门应当及时依法作出处理；不属于本部门职责的，应当及时移送有权处理的部门。</p><p>有关部门应当对举报人的相关信息予以保密，保护举报人的合法权益。</p><h3 id="第二章-网络安全支持与促进"><a href="#第二章-网络安全支持与促进" class="headerlink" title="第二章　网络安全支持与促进"></a>第二章　网络安全支持与促进</h3><h4 id="第十五条"><a href="#第十五条" class="headerlink" title="第十五条"></a>第十五条</h4><p>国家建立和完善网络安全标准体系。国务院标准化行政主管部门和国务院其他有关部门根据各自的职责，组织制定并适时修订有关网络安全管理以及网络产品、服务和运行安全的国家标准、行业标准。</p><p>国家支持企业、研究机构、高等学校、网络相关行业组织参与网络安全国家标准、行业标准的制定。</p><h4 id="第十六条"><a href="#第十六条" class="headerlink" title="第十六条"></a>第十六条</h4><p>国务院和省、自治区、直辖市人民政府应当统筹规划，加大投入，扶持重点网络安全技术产业和项目，支持网络安全技术的研究开发和应用，推广安全可信的网络产品和服务，保护网络技术知识产权，支持企业、研究机构和高等学校等参与国家网络安全技术创新项目。</p><h4 id="第十七条"><a href="#第十七条" class="headerlink" title="第十七条"></a>第十七条</h4><p>国家推进网络安全社会化服务体系建设，鼓励有关企业、机构开展网络安全认证、检测和风险评估等安全服务。</p><h4 id="第十八条"><a href="#第十八条" class="headerlink" title="第十八条"></a>第十八条</h4><p>国家鼓励开发网络数据安全保护和利用技术，促进公共数据资源开放，推动技术创新和经济社会发展。</p><p>国家支持创新网络安全管理方式，运用网络新技术，提升网络安全保护水平。</p><h4 id="第十九条"><a href="#第十九条" class="headerlink" title="第十九条"></a>第十九条</h4><p>各级人民政府及其有关部门应当组织开展经常性的网络安全宣传教育，并指导、督促有关单位做好网络安全宣传教育工作。</p><p>大众传播媒介应当有针对性地面向社会进行网络安全宣传教育。</p><h4 id="第二十条"><a href="#第二十条" class="headerlink" title="第二十条"></a>第二十条</h4><p>国家支持企业和高等学校、职业学校等教育培训机构开展网络安全相关教育与培训，采取多种方式培养网络安全人才，促进网络安全人才交流。</p><h3 id="第三章-网络运行安全"><a href="#第三章-网络运行安全" class="headerlink" title="第三章　网络运行安全"></a>第三章　网络运行安全</h3><p>第一节　一般规定</p><h4 id="第二十一条"><a href="#第二十一条" class="headerlink" title="第二十一条"></a>第二十一条</h4><p>国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改：</p><p>（一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任；</p><p>（二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施；</p><p>（三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月；</p><p>（四）采取数据分类、重要数据备份和加密等措施；</p><p>（五）法律、行政法规规定的其他义务。</p><h4 id="第二十二条"><a href="#第二十二条" class="headerlink" title="第二十二条"></a>第二十二条</h4><p>网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。</p><p>网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。</p><p>网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。</p><h4 id="第二十三条"><a href="#第二十三条" class="headerlink" title="第二十三条"></a>第二十三条</h4><p>网络关键设备和网络安全专用产品应当按照相关国家标准的强制性要求，由具备资格的机构安全认证合格或者安全检测符合要求后，方可销售或者提供。国家网信部门会同国务院有关部门制定、公布网络关键设备和网络安全专用产品目录，并推动安全认证和安全检测结果互认，避免重复认证、检测。</p><h4 id="第二十四条"><a href="#第二十四条" class="headerlink" title="第二十四条"></a>第二十四条</h4><p>网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。</p><p>国家实施网络可信身份战略，支持研究开发安全、方便的电子身份认证技术，推动不同电子身份认证之间的互认。</p><h4 id="第二十五条"><a href="#第二十五条" class="headerlink" title="第二十五条"></a>第二十五条</h4><p>网络运营者应当制定网络安全事件应急预案，及时处置系统漏洞、计算机病毒、网络攻击、网络侵入等安全风险；在发生危害网络安全的事件时，立即启动应急预案，采取相应的补救措施，并按照规定向有关主管部门报告。</p><h4 id="第二十六条【重点关注】"><a href="#第二十六条【重点关注】" class="headerlink" title="第二十六条【重点关注】"></a><font color="red">第二十六条【重点关注】</font></h4><p><strong>开展网络安全认证、检测、风险评估等活动，向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息，应当遵守国家有关规定。</strong></p><h4 id="第二十七条【重点关注】"><a href="#第二十七条【重点关注】" class="headerlink" title="第二十七条【重点关注】"></a><font color="red">第二十七条【重点关注】</font></h4><p><strong><font color="red">任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动</font>；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。</strong></p><h4 id="第二十八条"><a href="#第二十八条" class="headerlink" title="第二十八条"></a>第二十八条</h4><p>网络运营者应当为公安机关、国家安全机关依法维护国家安全和侦查犯罪的活动提供技术支持和协助。</p><h4 id="第二十九条"><a href="#第二十九条" class="headerlink" title="第二十九条"></a>第二十九条</h4><p>国家支持网络运营者之间在网络安全信息收集、分析、通报和应急处置等方面进行合作，提高网络运营者的安全保障能力。</p><p>有关行业组织建立健全本行业的网络安全保护规范和协作机制，加强对网络安全风险的分析评估，定期向会员进行风险警示，支持、协助会员应对网络安全风险。</p><h4 id="第三十条"><a href="#第三十条" class="headerlink" title="第三十条"></a>第三十条</h4><p>网信部门和有关部门在履行网络安全保护职责中获取的信息，只能用于维护网络安全的需要，不得用于其他用途。</p><p>第二节　关键信息基础设施的运行安全</p><h4 id="第三十一条"><a href="#第三十一条" class="headerlink" title="第三十一条"></a>第三十一条</h4><p>国家对公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的关键信息基础设施，在网络安全等级保护制度的基础上，实行重点保护。关键信息基础设施的具体范围和安全保护办法由国务院制定。</p><p>国家鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系。</p><h4 id="第三十二条"><a href="#第三十二条" class="headerlink" title="第三十二条"></a>第三十二条</h4><p>按照国务院规定的职责分工，负责关键信息基础设施安全保护工作的部门分别编制并组织实施本行业、本领域的关键信息基础设施安全规划，指导和监督关键信息基础设施运行安全保护工作。</p><h4 id="第三十三条"><a href="#第三十三条" class="headerlink" title="第三十三条"></a>第三十三条</h4><p>建设关键信息基础设施应当确保其具有支持业务稳定、持续运行的性能，并保证安全技术措施同步规划、同步建设、同步使用。</p><h4 id="第三十四条"><a href="#第三十四条" class="headerlink" title="第三十四条"></a>第三十四条</h4><p>除本法第二十一条的规定外，关键信息基础设施的运营者还应当履行下列安全保护义务：</p><p>（一）设置专门安全管理机构和安全管理负责人，并对该负责人和关键岗位的人员进行安全背景审查；</p><p>（二）定期对从业人员进行网络安全教育、技术培训和技能考核；</p><p>（三）对重要系统和数据库进行容灾备份；</p><p>（四）制定网络安全事件应急预案，并定期进行演练；</p><p>（五）法律、行政法规规定的其他义务。</p><h4 id="第三十五条"><a href="#第三十五条" class="headerlink" title="第三十五条"></a>第三十五条</h4><p>关键信息基础设施的运营者采购网络产品和服务，可能影响国家安全的，应当通过国家网信部门会同国务院有关部门组织的国家安全审查。</p><h4 id="第三十六条"><a href="#第三十六条" class="headerlink" title="第三十六条"></a>第三十六条</h4><p>关键信息基础设施的运营者采购网络产品和服务，应当按照规定与提供者签订安全保密协议，明确安全和保密义务与责任。</p><h4 id="第三十七条"><a href="#第三十七条" class="headerlink" title="第三十七条"></a>第三十七条</h4><p>关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要，确需向境外提供的，应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估；法律、行政法规另有规定的，依照其规定。</p><h4 id="第三十八条"><a href="#第三十八条" class="headerlink" title="第三十八条"></a>第三十八条</h4><p>关键信息基础设施的运营者应当自行或者委托网络安全服务机构对其网络的安全性和可能存在的风险每年至少进行一次检测评估，并将检测评估情况和改进措施报送相关负责关键信息基础设施安全保护工作的部门。</p><h4 id="第三十九条"><a href="#第三十九条" class="headerlink" title="第三十九条"></a>第三十九条</h4><p>国家网信部门应当统筹协调有关部门对关键信息基础设施的安全保护采取下列措施：</p><p>（一）对关键信息基础设施的安全风险进行抽查检测，提出改进措施，必要时可以委托网络安全服务机构对网络存在的安全风险进行检测评估；</p><p>（二）定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协同配合能力；</p><p>（三）促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络安全信息共享；</p><p>（四）对网络安全事件的应急处置与网络功能的恢复等，提供技术支持和协助。</p><h3 id="第四章-网络信息安全"><a href="#第四章-网络信息安全" class="headerlink" title="第四章　网络信息安全"></a>第四章　网络信息安全</h3><h4 id="第四十条"><a href="#第四十条" class="headerlink" title="第四十条"></a>第四十条</h4><p>网络运营者应当对其收集的用户信息严格保密，并建立健全用户信息保护制度。</p><h4 id="第四十一条"><a href="#第四十一条" class="headerlink" title="第四十一条"></a>第四十一条</h4><p>网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。</p><p>网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息。</p><h4 id="第四十二条【重点关注】"><a href="#第四十二条【重点关注】" class="headerlink" title="第四十二条【重点关注】"></a><font color="red">第四十二条【重点关注】</font></h4><p><strong>网络运营者不得泄露、篡改、毁损其收集的个人信息；未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。</strong></p><p>网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失。在发生或者可能发生个人信息泄露、毁损、丢失的情况时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。</p><h4 id="第四十三条"><a href="#第四十三条" class="headerlink" title="第四十三条"></a>第四十三条</h4><p>个人发现网络运营者违反法律、行政法规的规定或者双方的约定收集、使用其个人信息的，有权要求网络运营者删除其个人信息；发现网络运营者收集、存储的其个人信息有错误的，有权要求网络运营者予以更正。网络运营者应当采取措施予以删除或者更正。</p><h4 id="第四十四条【重点关注】"><a href="#第四十四条【重点关注】" class="headerlink" title="第四十四条【重点关注】"></a><font color="red">第四十四条【重点关注】</font></h4><p><strong>任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。</strong></p><h4 id="第四十五条【重点关注】"><a href="#第四十五条【重点关注】" class="headerlink" title="第四十五条【重点关注】"></a><font color="red">第四十五条【重点关注】</font></h4><p><strong>依法负有网络安全监督管理职责的部门及其工作人员，必须对在履行职责中知悉的个人信息、隐私和商业秘密严格保密，不得泄露、出售或者非法向他人提供。</strong></p><h4 id="第四十六条【重点关注】"><a href="#第四十六条【重点关注】" class="headerlink" title="第四十六条【重点关注】"></a><font color="red">第四十六条【重点关注】</font></h4><p><strong>任何个人和组织应当对其使用网络的行为负责，不得设立用于实施诈骗，传授犯罪方法，制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗，制作或者销售违禁物品、管制物品以及其他违法犯罪活动的信息。</strong></p><h4 id="第四十七条【重点关注】"><a href="#第四十七条【重点关注】" class="headerlink" title="第四十七条【重点关注】"></a><font color="red">第四十七条【重点关注】</font></h4><p><strong>网络运营者应当加强对其用户发布的信息的管理</strong>，发现法律、行政法规禁止发布或者传输的信息的，应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存有关记录，并向有关主管部门报告。</p><h4 id="第四十八条【重点关注】"><a href="#第四十八条【重点关注】" class="headerlink" title="第四十八条【重点关注】"></a><font color="red">第四十八条【重点关注】</font></h4><p><strong>任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。</strong></p><p>电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。</p><h4 id="第四十九条"><a href="#第四十九条" class="headerlink" title="第四十九条"></a>第四十九条</h4><p>网络运营者应当建立网络信息安全投诉、举报制度，公布投诉、举报方式等信息，及时受理并处理有关网络信息安全的投诉和举报。</p><p>网络运营者对网信部门和有关部门依法实施的监督检查，应当予以配合。</p><h4 id="第五十条"><a href="#第五十条" class="headerlink" title="第五十条"></a>第五十条</h4><p>国家网信部门和有关部门依法履行网络信息安全监督管理职责，发现法律、行政法规禁止发布或者传输的信息的，应当要求网络运营者停止传输，采取消除等处置措施，保存有关记录；对来源于中华人民共和国境外的上述信息，应当通知有关机构采取技术措施和其他必要措施阻断传播。</p><h3 id="第五章-监测预警与应急处置"><a href="#第五章-监测预警与应急处置" class="headerlink" title="第五章　监测预警与应急处置"></a>第五章　监测预警与应急处置</h3><h4 id="第五十一条"><a href="#第五十一条" class="headerlink" title="第五十一条"></a>第五十一条</h4><p>国家建立网络安全监测预警和信息通报制度。国家网信部门应当统筹协调有关部门加强网络安全信息收集、分析和通报工作，按照规定统一发布网络安全监测预警信息。</p><h4 id="第五十二条"><a href="#第五十二条" class="headerlink" title="第五十二条"></a>第五十二条</h4><p>负责关键信息基础设施安全保护工作的部门，应当建立健全本行业、本领域的网络安全监测预警和信息通报制度，并按照规定报送网络安全监测预警信息。</p><h4 id="第五十三条"><a href="#第五十三条" class="headerlink" title="第五十三条"></a>第五十三条</h4><p>国家网信部门协调有关部门建立健全网络安全风险评估和应急工作机制，制定网络安全事件应急预案，并定期组织演练。</p><p>负责关键信息基础设施安全保护工作的部门应当制定本行业、本领域的网络安全事件应急预案，并定期组织演练。</p><p>网络安全事件应急预案应当按照事件发生后的危害程度、影响范围等因素对网络安全事件进行分级，并规定相应的应急处置措施。</p><h4 id="第五十四条"><a href="#第五十四条" class="headerlink" title="第五十四条"></a>第五十四条</h4><p>网络安全事件发生的风险增大时，省级以上人民政府有关部门应当按照规定的权限和程序，并根据网络安全风险的特点和可能造成的危害，采取下列措施：</p><p>（一）要求有关部门、机构和人员及时收集、报告有关信息，加强对网络安全风险的监测；</p><p>（二）组织有关部门、机构和专业人员，对网络安全风险信息进行分析评估，预测事件发生的可能性、影响范围和危害程度；</p><p>（三）向社会发布网络安全风险预警，发布避免、减轻危害的措施。</p><h4 id="第五十五条"><a href="#第五十五条" class="headerlink" title="第五十五条"></a>第五十五条</h4><p>发生网络安全事件，应当立即启动网络安全事件应急预案，对网络安全事件进行调查和评估，要求网络运营者采取技术措施和其他必要措施，消除安全隐患，防止危害扩大，并及时向社会发布与公众有关的警示信息。</p><h4 id="第五十六条"><a href="#第五十六条" class="headerlink" title="第五十六条"></a>第五十六条</h4><p>省级以上人民政府有关部门在履行网络安全监督管理职责中，发现网络存在较大安全风险或者发生安全事件的，可以按照规定的权限和程序对该网络的运营者的法定代表人或者主要负责人进行约谈。网络运营者应当按照要求采取措施，进行整改，消除隐患。</p><h4 id="第五十七条"><a href="#第五十七条" class="headerlink" title="第五十七条"></a>第五十七条</h4><p>因网络安全事件，发生突发事件或者生产安全事故的，应当依照《中华人民共和国突发事件应对法》、《中华人民共和国安全生产法》等有关法律、行政法规的规定处置。</p><h4 id="第五十八条"><a href="#第五十八条" class="headerlink" title="第五十八条"></a>第五十八条</h4><p>因维护国家安全和社会公共秩序，处置重大突发社会安全事件的需要，经国务院决定或者批准，可以在特定区域对网络通信采取限制等临时措施。</p><h3 id="第六章-法律责任"><a href="#第六章-法律责任" class="headerlink" title="第六章　法律责任"></a>第六章　法律责任</h3><h4 id="第五十九条"><a href="#第五十九条" class="headerlink" title="第五十九条"></a>第五十九条</h4><p>网络运营者不履行本法第二十一条、第二十五条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。</p><p>关键信息基础设施的运营者不履行本法第三十三条、第三十四条、第三十六条、第三十八条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。</p><h4 id="第六十条"><a href="#第六十条" class="headerlink" title="第六十条"></a>第六十条</h4><p>违反本法第二十二条第一款、第二款和第四十八条第一款规定，有下列行为之一的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处五万元以上五十万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款：</p><p>（一）设置恶意程序的；</p><p>（二）对其产品、服务存在的安全缺陷、漏洞等风险未立即采取补救措施，或者未按照规定及时告知用户并向有关主管部门报告的；</p><p>（三）擅自终止为其产品、服务提供安全维护的。</p><h4 id="第六十一条"><a href="#第六十一条" class="headerlink" title="第六十一条"></a>第六十一条</h4><p>网络运营者违反本法第二十四条第一款规定，未要求用户提供真实身份信息，或者对不提供真实身份信息的用户提供相关服务的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><h4 id="第六十二条【重点关注】"><a href="#第六十二条【重点关注】" class="headerlink" title="第六十二条【重点关注】"></a><font color="red">第六十二条【重点关注】</font></h4><p><strong>违反本法第二十六条规定，开展网络安全认证、检测、风险评估等活动，或者向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息的，由有关主管部门责令改正，给予警告；拒不改正或者情节严重的，处一万元以上十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处五千元以上五万元以下罚款。</strong></p><h4 id="第六十三条【重点关注】"><a href="#第六十三条【重点关注】" class="headerlink" title="第六十三条【重点关注】"></a><font color="red">第六十三条【重点关注】</font></h4><p><strong>违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。</strong></p><p><strong>单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。</strong></p><p><strong>违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。</strong></p><h4 id="第六十四条"><a href="#第六十四条" class="headerlink" title="第六十四条"></a>第六十四条</h4><p>网络运营者、网络产品或者服务的提供者违反本法第二十二条第三款、第四十一条至第四十三条规定，侵害个人信息依法得到保护的权利的，由有关主管部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款；情节严重的，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照。</p><p>违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。</p><h4 id="第六十五条"><a href="#第六十五条" class="headerlink" title="第六十五条"></a>第六十五条</h4><p>关键信息基础设施的运营者违反本法第三十五条规定，使用未经安全审查或者安全审查未通过的网络产品或者服务的，由有关主管部门责令停止使用，处采购金额一倍以上十倍以下罚款；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><h4 id="第六十六条"><a href="#第六十六条" class="headerlink" title="第六十六条"></a>第六十六条</h4><p>关键信息基础设施的运营者违反本法第三十七条规定，在境外存储网络数据，或者向境外提供网络数据的，由有关主管部门责令改正，给予警告，没收违法所得，处五万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><h4 id="第六十七条【重点关注】"><a href="#第六十七条【重点关注】" class="headerlink" title="第六十七条【重点关注】"></a><font color="red">第六十七条【重点关注】</font></h4><p><strong>违反本法第四十六条规定，设立用于实施违法犯罪活动的网站、通讯群组，或者利用网络发布涉及实施违法犯罪活动的信息</strong>，尚不构成犯罪的，由公安机关处五日以下拘留，</p><p>可以并处一万元以上十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处五万元以上五十万元以下罚款。关闭用于实施违法犯罪活动的网站、通讯群组。</p><p>单位有前款行为的，由公安机关处十万元以上五十万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。</p><h4 id="第六十八条"><a href="#第六十八条" class="headerlink" title="第六十八条"></a>第六十八条</h4><p>网络运营者违反本法第四十七条规定，对法律、行政法规禁止发布或者传输的信息未停止传输、采取消除等处置措施、保存有关记录的，由有关主管部门责令改正，给予警告，没收违法所得；拒不改正或者情节严重的，处十万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><p>电子信息发送服务提供者、应用软件下载服务提供者，不履行本法第四十八条第二款规定的安全管理义务的，依照前款规定处罚。</p><h4 id="第六十九条"><a href="#第六十九条" class="headerlink" title="第六十九条"></a>第六十九条</h4><p>网络运营者违反本法规定，有下列行为之一的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，对直接负责的主管人员和其他直接责任人员，处一万元以上十万元以下罚款：</p><p>（一）不按照有关部门的要求对法律、行政法规禁止发布或者传输的信息，采取停止传输、消除等处置措施的；</p><p>（二）拒绝、阻碍有关部门依法实施的监督检查的；</p><p>（三）拒不向公安机关、国家安全机关提供技术支持和协助的。</p><h4 id="第七十条"><a href="#第七十条" class="headerlink" title="第七十条"></a>第七十条</h4><p>发布或者传输本法第十二条第二款和其他法律、行政法规禁止发布或者传输的信息的，依照有关法律、行政法规的规定处罚。</p><h4 id="第七十一条【重点关注】"><a href="#第七十一条【重点关注】" class="headerlink" title="第七十一条【重点关注】"></a><font color="red">第七十一条【重点关注】</font></h4><p>有本法规定的违法行为的，依照有关法律、行政法规的规定记入信用档案，并予以公示。</p><h4 id="第七十二条"><a href="#第七十二条" class="headerlink" title="第七十二条"></a>第七十二条</h4><p>国家机关政务网络的运营者不履行本法规定的网络安全保护义务的，由其上级机关或者有关机关责令改正；对直接负责的主管人员和其他直接责任人员依法给予处分。</p><h4 id="第七十三条"><a href="#第七十三条" class="headerlink" title="第七十三条"></a>第七十三条</h4><p>网信部门和有关部门违反本法第三十条规定，将在履行网络安全保护职责中获取的信息用于其他用途的，对直接负责的主管人员和其他直接责任人员依法给予处分。</p><p>网信部门和有关部门的工作人员玩忽职守、滥用职权、徇私舞弊，尚不构成犯罪的，依法给予处分。</p><h4 id="第七十四条【重点关注】"><a href="#第七十四条【重点关注】" class="headerlink" title="第七十四条【重点关注】"></a><font color="red">第七十四条【重点关注】</font></h4><p><strong>违反本法规定，给他人造成损害的，依法承担民事责任。</strong></p><p><strong>违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。</strong></p><h4 id="第七十五条【重点关注】"><a href="#第七十五条【重点关注】" class="headerlink" title="第七十五条【重点关注】"></a><font color="red">第七十五条【重点关注】</font></h4><p><strong>境外的机构、组织、个人从事攻击、侵入、干扰、破坏等危害中华人民共和国的关键信息基础设施的活动，造成严重后果的，依法追究法律责任</strong>；国务院公安部门和有关部门并可以决定对该机构、组织、个人采取冻结财产或者其他必要的制裁措施。</p><h3 id="第七章-附-则"><a href="#第七章-附-则" class="headerlink" title="第七章　附　则"></a>第七章　附　则</h3><h4 id="第七十六条"><a href="#第七十六条" class="headerlink" title="第七十六条"></a>第七十六条</h4><p>本法下列用语的含义：</p><p>（一）网络，是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。</p><p>（二）网络安全，是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性的能力。</p><p>（三）网络运营者，是指网络的所有者、管理者和网络服务提供者。</p><p>（四）网络数据，是指通过网络收集、存储、传输、处理和产生的各种电子数据。</p><p>（五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。</p><h4 id="第七十七条"><a href="#第七十七条" class="headerlink" title="第七十七条"></a>第七十七条</h4><p>存储、处理涉及国家秘密信息的网络的运行安全保护，除应当遵守本法外，还应当遵守保密法律、行政法规的规定。</p><h4 id="第七十八条"><a href="#第七十八条" class="headerlink" title="第七十八条"></a>第七十八条</h4><p>军事网络的安全保护，由中央军事委员会另行规定。</p><h4 id="第七十九条"><a href="#第七十九条" class="headerlink" title="第七十九条"></a>第七十九条</h4><p>本法自2017年6月1日起施行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>没有授权的渗透测试不要做</li><li>渗透测试拿到的数据不要外泄</li><li>不要发布违法信息、非法工具、手头的漏洞</li><li>绝对不要碰数据！！！（只要你碰数据了，80%的概率就触犯刑法了）</li></ol>]]></content>
    
    
    <categories>
      
      <category>法律法规</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
